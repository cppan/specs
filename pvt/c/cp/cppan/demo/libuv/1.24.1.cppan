{
    "project": "pvt.cppan.demo.libuv",
    "cppan": "source:\n    git: https:\/\/github.com\/libuv\/libuv\n    tag: v{v}\n\nversion: 1.24.1\n\noptions:\n    shared:\n        definitions:\n            interface:\n                -   USING_UV_SHARED\n            private:\n                -   BUILDING_UV_SHARED\n\npatch:\n    replace:\n        unidiff_patch_src\/win\/process.c: \"--- process.c\\t2019-01-13 12:23:06.565785200 +0300\\n+++ process.c\\t2019-01-13 19:56:15.053137500 +0300\\n@@ -943,7 +943,7 @@\\n   BOOL result;\\n   WCHAR* application_path = NULL, *application = NULL, *arguments = NULL,\\n          *env = NULL, *cwd = NULL;\\n-  STARTUPINFOW startup;\\n+  STARTUPINFOEXW startup;\\n   PROCESS_INFORMATION info;\\n   DWORD process_flags;\\n \\n@@ -1052,20 +1052,50 @@\\n     goto done;\\n   }\\n \\n-  startup.cb = sizeof(startup);\\n-  startup.lpReserved = NULL;\\n-  startup.lpDesktop = NULL;\\n-  startup.lpTitle = NULL;\\n-  startup.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\\n-\\n-  startup.cbReserved2 = uv__stdio_size(process->child_stdio_buffer);\\n-  startup.lpReserved2 = (BYTE*) process->child_stdio_buffer;\\n-\\n-  startup.hStdInput = uv__stdio_handle(process->child_stdio_buffer, 0);\\n-  startup.hStdOutput = uv__stdio_handle(process->child_stdio_buffer, 1);\\n-  startup.hStdError = uv__stdio_handle(process->child_stdio_buffer, 2);\\n+  startup.StartupInfo.cb = sizeof(startup);\\n+  startup.StartupInfo.lpReserved = NULL;\\n+  startup.StartupInfo.lpDesktop = NULL;\\n+  startup.StartupInfo.lpTitle = NULL;\\n+  startup.StartupInfo.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\\n+\\n+  startup.StartupInfo.cbReserved2 = uv__stdio_size(process->child_stdio_buffer);\\n+  startup.StartupInfo.lpReserved2 = (BYTE*) process->child_stdio_buffer;\\n+\\n+  startup.StartupInfo.hStdInput = uv__stdio_handle(process->child_stdio_buffer, 0);\\n+  startup.StartupInfo.hStdOutput = uv__stdio_handle(process->child_stdio_buffer, 1);\\n+  startup.StartupInfo.hStdError = uv__stdio_handle(process->child_stdio_buffer, 2);\\n+\\n+  const auto cHandlesToInherit = 3;\\n+  HANDLE rgHandlesToInherit[] = {\\n+      startup.StartupInfo.hStdInput,\\n+      startup.StartupInfo.hStdOutput,\\n+      startup.StartupInfo.hStdError,\\n+  };\\n+  SIZE_T size = 0;\\n+  LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList = NULL;\\n+  BOOL fSuccess;\\n+  BOOL fInitialized = FALSE;\\n+    fSuccess = InitializeProcThreadAttributeList(NULL, 1, 0, &size) ||\\n+        GetLastError() == ERROR_INSUFFICIENT_BUFFER;\\n+  if (fSuccess) {\\n+      lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)\\n+          (HeapAlloc(GetProcessHeap(), 0, size));\\n+      fSuccess = lpAttributeList != NULL;\\n+  }\\n+  if (fSuccess) {\\n+      fSuccess = InitializeProcThreadAttributeList(lpAttributeList,\\n+          1, 0, &size);\\n+  }\\n+  if (fSuccess) {\\n+      fInitialized = TRUE;\\n+      fSuccess = UpdateProcThreadAttribute(lpAttributeList,\\n+          0, PROC_THREAD_ATTRIBUTE_HANDLE_LIST,\\n+          rgHandlesToInherit,\\n+          cHandlesToInherit * sizeof(HANDLE), NULL, NULL);\\n+  }\\n+  startup.lpAttributeList = lpAttributeList;\\n \\n-  process_flags = CREATE_UNICODE_ENVIRONMENT;\\n+  process_flags = CREATE_UNICODE_ENVIRONMENT | EXTENDED_STARTUPINFO_PRESENT;\\n \\n   if ((options->flags & UV_PROCESS_WINDOWS_HIDE_CONSOLE) ||\\n       (options->flags & UV_PROCESS_WINDOWS_HIDE)) {\\n@@ -1080,9 +1110,9 @@\\n   if ((options->flags & UV_PROCESS_WINDOWS_HIDE_GUI) ||\\n       (options->flags & UV_PROCESS_WINDOWS_HIDE)) {\\n     \/* Use SW_HIDE to avoid any potential process window. *\/\\n-    startup.wShowWindow = SW_HIDE;\\n+    startup.StartupInfo.wShowWindow = SW_HIDE;\\n   } else {\\n-    startup.wShowWindow = SW_SHOWDEFAULT;\\n+    startup.StartupInfo.wShowWindow = SW_SHOWDEFAULT;\\n   }\\n \\n   if (options->flags & UV_PROCESS_DETACHED) {\\n@@ -1107,7 +1137,7 @@\\n                      process_flags,\\n                      env,\\n                      cwd,\\n-                     &startup,\\n+                     (STARTUPINFOW*)&startup,\\n                      &info)) {\\n     \/* CreateProcessW failed. *\/\\n     err = GetLastError();\\n@@ -1169,7 +1199,10 @@\\n   uv__handle_start(process);\\n \\n   \/* Cleanup, whether we succeeded or failed. *\/\\n- done:\\n+done:\\n+  if (fInitialized) DeleteProcThreadAttributeList(lpAttributeList);\\n+  if (lpAttributeList) HeapFree(GetProcessHeap(), 0, lpAttributeList);\\n+\\n   uv__free(application);\\n   uv__free(application_path);\\n   uv__free(arguments);\\n\"\n\npost_sources: |\n    if (WIN32)\n        file(GLOB src \"src\/*\")\n        file(GLOB src2 \"src\/win\/*\")\n    else()\n        file(GLOB src \"src\/*\")\n        set(src ${src}\n          src\/unix\/async.c\n          src\/unix\/atomic-ops.h\n          src\/unix\/core.c\n          src\/unix\/dl.c\n          src\/unix\/fs.c\n          src\/unix\/getaddrinfo.c\n          src\/unix\/getnameinfo.c\n          src\/unix\/internal.h\n          src\/unix\/loop-watcher.c\n          src\/unix\/loop.c\n          src\/unix\/pipe.c\n          src\/unix\/poll.c\n          src\/unix\/process.c\n          src\/unix\/signal.c\n          src\/unix\/spinlock.h\n          src\/unix\/stream.c\n          src\/unix\/tcp.c\n          src\/unix\/thread.c\n          src\/unix\/tty.c\n          src\/unix\/udp.c\n        )\n    \n          if (AIX)\n            set(src ${src}\n                src\/unix\/aix.c\n            )\n          elseif (ANDROID)\n            set(src ${src}\n                src\/unix\/android-ifaddrs.c\n                src\/unix\/pthread-fixes.c\n            )\n          elseif (APPLE OR DARWIN)\n            set(src ${src}\n                src\/unix\/darwin.c\n                src\/unix\/darwin-proctitle.c\n                src\/unix\/fsevents.c\n                src\/unix\/kqueue.c\n                src\/unix\/proctitle.c\n            )\n          elseif (FREEBSD)\n            set(src ${src}\n                src\/unix\/freebsd.c\n                src\/unix\/kqueue.c\n            )\n          elseif (NETBSD)\n            set(src ${src}\n                src\/unix\/kqueue.c\n                src\/unix\/netbsd.c\n            )\n          elseif (OPENBSD)\n            set(src ${src}\n                src\/unix\/kqueue.c\n                src\/unix\/openbsd.c\n            )\n          elseif (SUNOS)\n            set(src ${src}\n              src\/unix\/sunos.c\n            )\n          else() # LINUX\n            set(src ${src}\n                src\/unix\/linux-core.c\n                src\/unix\/linux-inotify.c\n                src\/unix\/linux-syscalls.c\n                src\/unix\/linux-syscalls.h\n                src\/unix\/proctitle.c\n            )\n          endif()\n      endif()\n    \n      set(src ${src} ${src2})\n\npost_target: |\n    if (WIN32)\n        target_link_libraries(${this} PUBLIC iphlpapi psapi userenv)\n    endif()\n\n",
    "source": {
        "git": {
            "url": "https:\/\/github.com\/libuv\/libuv",
            "tag": "v{v}"
        }
    },
    "version": "1.24.1",
    "hash": "d1a7a771a6433065f263c5a8bfbcec6a981750a3ceee8f6fb729c9a99a44b8e5",
    "created": "2019-01-13 22:20:42.219417"
}
