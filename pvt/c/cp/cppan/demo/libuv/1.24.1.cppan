{
    "project": "pvt.cppan.demo.libuv",
    "cppan": "source:\n    git: https:\/\/github.com\/libuv\/libuv\n    tag: v{v}\n\nversion: 1.24.1\n\noptions:\n    shared:\n        definitions:\n            interface:\n                -   USING_UV_SHARED\n            private:\n                -   BUILDING_UV_SHARED\n\npatch:\n    replace:\n        unidiff_patch_include\/uv.h: \"--- bef5\/include\/uv.h\\t2019-01-14 19:34:30.586129300 +0300\\n+++ bef51\/include\/uv.h\\t2019-01-14 04:33:15.209648100 +0300\\n@@ -930,6 +930,12 @@\\n    *\/\\n   uv_uid_t uid;\\n   uv_gid_t gid;\\n+  \/*\\n+   * Represents a set of attributes that passed with STARTUPINFOEXW\\n+   * on Windows. This is not supported on unix; uv_spawn() will fail\\n+   * and set the error to UV_ENOTSUP.\\n+   *\/\\n+  void *attribute_list;\\n } uv_process_options_t;\\n \\n \/*\\n@@ -978,7 +984,11 @@\\n    * option is only meaningful on Windows systems. On Unix it is silently\\n    * ignored.\\n    *\/\\n-  UV_PROCESS_WINDOWS_HIDE_GUI = (1 << 6)\\n+  UV_PROCESS_WINDOWS_HIDE_GUI = (1 << 6),\\n+  \/*\\n+   * Create new console.\\n+   *\/\\n+  UV_PROCESS_WINDOWS_ALLOC_CONSOLE = (1 << 7),\\n };\\n \\n \/*\\n\"\n        unidiff_patch_src\/unix\/process.c: \"--- bef5\/src\/unix\/process.c\\t2019-01-14 19:34:30.561194200 +0300\\n+++ bef51\/src\/unix\/process.c\\t2019-01-14 02:04:56.462853100 +0300\\n@@ -426,6 +426,10 @@\\n   int i;\\n   int status;\\n \\n+  if (options->attribute_list != NULL) {\\n+      return UV_ENOTSUP;\\n+  }\\n+\\n   assert(options->file != NULL);\\n   assert(!(options->flags & ~(UV_PROCESS_DETACHED |\\n                               UV_PROCESS_SETGID |\\n\"\n        unidiff_patch_src\/win\/process.c: \"--- bef5\/src\/win\/process.c\\t2019-01-14 19:34:30.683714200 +0300\\n+++ bef51\/src\/win\/process.c\\t2019-01-14 04:54:15.061879400 +0300\\n@@ -943,7 +943,7 @@\\n   BOOL result;\\n   WCHAR* application_path = NULL, *application = NULL, *arguments = NULL,\\n          *env = NULL, *cwd = NULL;\\n-  STARTUPINFOW startup;\\n+  STARTUPINFOEXW startup;\\n   PROCESS_INFORMATION info;\\n   DWORD process_flags;\\n \\n@@ -965,6 +965,7 @@\\n                               UV_PROCESS_SETUID |\\n                               UV_PROCESS_WINDOWS_HIDE |\\n                               UV_PROCESS_WINDOWS_HIDE_CONSOLE |\\n+                              UV_PROCESS_WINDOWS_ALLOC_CONSOLE |\\n                               UV_PROCESS_WINDOWS_HIDE_GUI |\\n                               UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS)));\\n \\n@@ -1052,20 +1053,58 @@\\n     goto done;\\n   }\\n \\n-  startup.cb = sizeof(startup);\\n-  startup.lpReserved = NULL;\\n-  startup.lpDesktop = NULL;\\n-  startup.lpTitle = NULL;\\n-  startup.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\\n-\\n-  startup.cbReserved2 = uv__stdio_size(process->child_stdio_buffer);\\n-  startup.lpReserved2 = (BYTE*) process->child_stdio_buffer;\\n-\\n-  startup.hStdInput = uv__stdio_handle(process->child_stdio_buffer, 0);\\n-  startup.hStdOutput = uv__stdio_handle(process->child_stdio_buffer, 1);\\n-  startup.hStdError = uv__stdio_handle(process->child_stdio_buffer, 2);\\n+  startup.StartupInfo.cb = sizeof(startup);\\n+  startup.StartupInfo.lpReserved = NULL;\\n+  startup.StartupInfo.lpDesktop = NULL;\\n+  startup.StartupInfo.lpTitle = NULL;\\n+  startup.StartupInfo.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\\n+\\n+  startup.StartupInfo.cbReserved2 = uv__stdio_size(process->child_stdio_buffer);\\n+  startup.StartupInfo.lpReserved2 = (BYTE*) process->child_stdio_buffer;\\n+\\n+  startup.StartupInfo.hStdInput = uv__stdio_handle(process->child_stdio_buffer, 0);\\n+  startup.StartupInfo.hStdOutput = uv__stdio_handle(process->child_stdio_buffer, 1);\\n+  startup.StartupInfo.hStdError = uv__stdio_handle(process->child_stdio_buffer, 2);\\n+\\n+  const auto cHandlesToInherit = 3;\\n+  HANDLE rgHandlesToInherit[] = {\\n+      startup.StartupInfo.hStdInput,\\n+      startup.StartupInfo.hStdOutput,\\n+      startup.StartupInfo.hStdError,\\n+  };\\n+  SIZE_T size = 0;\\n+  LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)options->attribute_list;\\n+  BOOL fSuccess = TRUE;\\n+  BOOL fInitialized = FALSE;\\n+  if (!(options->flags & UV_PROCESS_WINDOWS_ALLOC_CONSOLE)) {\\n+    if (!lpAttributeList) {\\n+        fSuccess = InitializeProcThreadAttributeList(NULL, 1, 0, &size) ||\\n+        GetLastError() == ERROR_INSUFFICIENT_BUFFER;\\n+        if (fSuccess) {\\n+            lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)\\n+                (HeapAlloc(GetProcessHeap(), 0, size));\\n+            fSuccess = lpAttributeList != NULL;\\n+        }\\n+        if (fSuccess) {\\n+            fSuccess = InitializeProcThreadAttributeList(lpAttributeList,\\n+                1, 0, &size);\\n+        }\\n+    }\\n+    if (fSuccess) {\\n+        fInitialized = TRUE;\\n+        fSuccess = UpdateProcThreadAttribute(lpAttributeList,\\n+            0, PROC_THREAD_ATTRIBUTE_HANDLE_LIST,\\n+            rgHandlesToInherit,\\n+            cHandlesToInherit * sizeof(HANDLE), NULL, NULL);\\n+        if (!fSuccess) {\\n+            err = GetLastError();\\n+            goto done;\\n+        }\\n+    }\\n+  }\\n+  startup.lpAttributeList = lpAttributeList;\\n \\n-  process_flags = CREATE_UNICODE_ENVIRONMENT;\\n+  process_flags = CREATE_UNICODE_ENVIRONMENT | EXTENDED_STARTUPINFO_PRESENT;\\n \\n   if ((options->flags & UV_PROCESS_WINDOWS_HIDE_CONSOLE) ||\\n       (options->flags & UV_PROCESS_WINDOWS_HIDE)) {\\n@@ -1080,12 +1119,17 @@\\n   if ((options->flags & UV_PROCESS_WINDOWS_HIDE_GUI) ||\\n       (options->flags & UV_PROCESS_WINDOWS_HIDE)) {\\n     \/* Use SW_HIDE to avoid any potential process window. *\/\\n-    startup.wShowWindow = SW_HIDE;\\n+    startup.StartupInfo.wShowWindow = SW_HIDE;\\n   } else {\\n-    startup.wShowWindow = SW_SHOWDEFAULT;\\n+    startup.StartupInfo.wShowWindow = SW_SHOWDEFAULT;\\n   }\\n \\n-  if (options->flags & UV_PROCESS_DETACHED) {\\n+  BOOL inheritHandles = TRUE;\\n+  if (options->flags & UV_PROCESS_WINDOWS_ALLOC_CONSOLE) {\\n+    process_flags |= CREATE_NEW_CONSOLE;\\n+    inheritHandles = FALSE;\\n+  }\\n+  else if (options->flags & UV_PROCESS_DETACHED) {\\n     \/* Note that we're not setting the CREATE_BREAKAWAY_FROM_JOB flag. That\\n      * means that libuv might not let you create a fully daemonized process\\n      * when run under job control. However the type of job control that libuv\\n@@ -1103,11 +1147,11 @@\\n                      arguments,\\n                      NULL,\\n                      NULL,\\n-                     1,\\n+                     inheritHandles,\\n                      process_flags,\\n                      env,\\n                      cwd,\\n-                     &startup,\\n+                     (STARTUPINFOW*)&startup,\\n                      &info)) {\\n     \/* CreateProcessW failed. *\/\\n     err = GetLastError();\\n@@ -1169,7 +1213,12 @@\\n   uv__handle_start(process);\\n \\n   \/* Cleanup, whether we succeeded or failed. *\/\\n- done:\\n+done:\\n+  if (!options->attribute_list) {\\n+      if (fInitialized) DeleteProcThreadAttributeList(lpAttributeList);\\n+      if (lpAttributeList) HeapFree(GetProcessHeap(), 0, lpAttributeList);\\n+  }\\n+\\n   uv__free(application);\\n   uv__free(application_path);\\n   uv__free(arguments);\\n\"\n\npost_sources: |\n    if (WIN32)\n        file(GLOB src \"src\/*\")\n        file(GLOB src2 \"src\/win\/*\")\n    else()\n        file(GLOB src \"src\/*\")\n        set(src ${src}\n          src\/unix\/async.c\n          src\/unix\/atomic-ops.h\n          src\/unix\/core.c\n          src\/unix\/dl.c\n          src\/unix\/fs.c\n          src\/unix\/getaddrinfo.c\n          src\/unix\/getnameinfo.c\n          src\/unix\/internal.h\n          src\/unix\/loop-watcher.c\n          src\/unix\/loop.c\n          src\/unix\/pipe.c\n          src\/unix\/poll.c\n          src\/unix\/process.c\n          src\/unix\/signal.c\n          src\/unix\/spinlock.h\n          src\/unix\/stream.c\n          src\/unix\/tcp.c\n          src\/unix\/thread.c\n          src\/unix\/tty.c\n          src\/unix\/udp.c\n        )\n    \n          if (AIX)\n            set(src ${src}\n                src\/unix\/aix.c\n            )\n          elseif (ANDROID)\n            set(src ${src}\n                src\/unix\/android-ifaddrs.c\n                src\/unix\/pthread-fixes.c\n            )\n          elseif (APPLE OR DARWIN)\n            set(src ${src}\n                src\/unix\/darwin.c\n                src\/unix\/darwin-proctitle.c\n                src\/unix\/fsevents.c\n                src\/unix\/kqueue.c\n                src\/unix\/proctitle.c\n            )\n          elseif (FREEBSD)\n            set(src ${src}\n                src\/unix\/freebsd.c\n                src\/unix\/kqueue.c\n            )\n          elseif (NETBSD)\n            set(src ${src}\n                src\/unix\/kqueue.c\n                src\/unix\/netbsd.c\n            )\n          elseif (OPENBSD)\n            set(src ${src}\n                src\/unix\/kqueue.c\n                src\/unix\/openbsd.c\n            )\n          elseif (SUNOS)\n            set(src ${src}\n              src\/unix\/sunos.c\n            )\n          else() # LINUX\n            set(src ${src}\n                src\/unix\/linux-core.c\n                src\/unix\/linux-inotify.c\n                src\/unix\/linux-syscalls.c\n                src\/unix\/linux-syscalls.h\n                src\/unix\/proctitle.c\n            )\n          endif()\n      endif()\n    \n      set(src ${src} ${src2})\n\npost_target: |\n    if (WIN32)\n        target_link_libraries(${this} PUBLIC iphlpapi psapi userenv)\n    endif()\n\n",
    "source": {
        "git": {
            "url": "https:\/\/github.com\/libuv\/libuv",
            "tag": "v{v}"
        }
    },
    "version": "1.24.1",
    "hash": "b14e4ab30add04118ccba80af455f90eb2644ab9f4ed9fe490f924ce3c5df6c7",
    "created": "2019-01-14 17:04:04.469129"
}
