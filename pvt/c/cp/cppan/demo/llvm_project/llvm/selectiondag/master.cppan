{
    "project": "pvt.cppan.demo.llvm_project.llvm.selectiondag",
    "version": "master",
    "cppan": "source:\n    git: https:\/\/github.com\/llvm-mirror\/llvm\n    branch: master\n\nversion: master\n\ntype: library\n\nstatic_only: true\n\nfiles:\n    -   lib\/CodeGen\/SelectionDAG\/[^\/]*\n\ndependencies:\n    public:\n        pvt.cppan.demo.llvm_project.llvm.codegen:\n            version: \"*\"\n        pvt.cppan.demo.llvm_project.llvm.transformutils:\n            version: \"*\"\n\npre_project: |\n    if(MSVC)\n      # Remove flags here, for exceptions and RTTI.\n      # Each target property or source property should be responsible to control\n      # them.\n      # CL.EXE complains to override flags like \"\/GR \/GR-\".\n      string(REGEX REPLACE \"(^| ) *\/EH[-cs]+ *( |$)\" \"\\\\1 \\\\2\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n      string(REGEX REPLACE \"(^| ) *\/GR-? *( |$)\" \"\\\\1 \\\\2\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n    endif()\n\npost_sources: |\n    set(LLVM_VERSION_MAJOR ${PACKAGE_VERSION_MAJOR})\n    set(LLVM_VERSION_MINOR ${PACKAGE_VERSION_MINOR})\n    set(LLVM_VERSION_PATCH ${PACKAGE_VERSION_PATCH})\n    if(NOT DEFINED LLVM_VERSION_SUFFIX)\n      set(LLVM_VERSION_SUFFIX cppan)\n    endif()\n    \n    \n    \n    find_package(Backtrace QUIET)\n    set(HAVE_BACKTRACE ${Backtrace_FOUND})\n    set(BACKTRACE_HEADER ${Backtrace_HEADER})\n    \n    check_symbol_exists(FE_ALL_EXCEPT \"fenv.h\" HAVE_DECL_FE_ALL_EXCEPT)\n    check_symbol_exists(FE_INEXACT \"fenv.h\" HAVE_DECL_FE_INEXACT)\n    check_symbol_exists(arc4random \"stdlib.h\" HAVE_DECL_ARC4RANDOM)\n    check_symbol_exists(strerror_s string.h HAVE_DECL_STRERROR_S)\n    \n    # This should only apply if you are both on an Apple host, and targeting Apple.\n    if(CMAKE_HOST_APPLE AND APPLE)\n      # if CMAKE_LIBTOOL is not set, try and find it with xcrun or find_program\n      if(NOT CMAKE_LIBTOOL)\n        if(NOT CMAKE_XCRUN)\n          find_program(CMAKE_XCRUN NAMES xcrun)\n        endif()\n        if(CMAKE_XCRUN)\n          execute_process(COMMAND ${CMAKE_XCRUN} -find libtool\n            OUTPUT_VARIABLE CMAKE_LIBTOOL\n            OUTPUT_STRIP_TRAILING_WHITESPACE)\n        endif()\n    \n        if(NOT CMAKE_LIBTOOL OR NOT EXISTS CMAKE_LIBTOOL)\n          find_program(CMAKE_LIBTOOL NAMES libtool)\n        endif()\n      endif()\n    \n      get_property(languages GLOBAL PROPERTY ENABLED_LANGUAGES)\n      if(CMAKE_LIBTOOL)\n        set(CMAKE_LIBTOOL ${CMAKE_LIBTOOL} CACHE PATH \"libtool executable\")\n        message(STATUS \"Found libtool - ${CMAKE_LIBTOOL}\")\n    \n        execute_process(COMMAND ${CMAKE_LIBTOOL} -V\n          OUTPUT_VARIABLE LIBTOOL_V_OUTPUT\n          OUTPUT_STRIP_TRAILING_WHITESPACE)\n        if(\"${LIBTOOL_V_OUTPUT}\" MATCHES \".*cctools-([0-9.]+).*\")\n          string(REGEX REPLACE \".*cctools-([0-9.]+).*\" \"\\\\1\" LIBTOOL_VERSION\n            ${LIBTOOL_V_OUTPUT})\n          if(NOT LIBTOOL_VERSION VERSION_LESS \"862\")\n            set(LIBTOOL_NO_WARNING_FLAG \"-no_warning_for_no_symbols\")\n          endif()\n        endif()\n    \n        foreach(lang ${languages})\n          set(CMAKE_${lang}_CREATE_STATIC_LIBRARY\n            \"${CMAKE_LIBTOOL} -static ${LIBTOOL_NO_WARNING_FLAG} -o <TARGET> \\\n            <LINK_FLAGS> <OBJECTS> \")\n        endforeach()\n      endif()\n    \n      # If DYLD_LIBRARY_PATH is set we need to set it on archiver commands\n      if(DYLD_LIBRARY_PATH)\n        set(dyld_envar \"DYLD_LIBRARY_PATH=${DYLD_LIBRARY_PATH}\")\n        foreach(lang ${languages})\n          foreach(cmd ${CMAKE_${lang}_CREATE_STATIC_LIBRARY})\n            list(APPEND CMAKE_${lang}_CREATE_STATIC_LIBRARY_NEW\n                 \"${dyld_envar} ${cmd}\")\n          endforeach()\n          set(CMAKE_${lang}_CREATE_STATIC_LIBRARY\n            ${CMAKE_${lang}_CREATE_STATIC_LIBRARY_NEW})\n        endforeach()\n      endif()\n    endif()\n    \n    # Build llvm with ccache if the package is present\n    set(LLVM_CCACHE_BUILD OFF CACHE BOOL \"Set to ON for a ccache enabled build\")\n    \n    option(LLVM_DEPENDENCY_DEBUGGING \"Dependency debugging mode to verify correctly expressed library dependencies (Darwin only)\" OFF)\n    \n    # Some features of the LLVM build may be disallowed when dependency debugging is\n    # enabled. In particular you cannot use ccache because we want to force compile\n    # operations to always happen.\n    if(LLVM_DEPENDENCY_DEBUGGING)\n      if(NOT CMAKE_HOST_APPLE)\n        message(FATAL_ERROR \"Dependency debugging is only currently supported on Darwin hosts.\")\n      endif()\n      if(LLVM_CCACHE_BUILD)\n        message(FATAL_ERROR \"Cannot enable dependency debugging while using ccache.\")\n      endif()\n    endif()\n    \n    option(LLVM_BUILD_GLOBAL_ISEL \"Experimental: Build GlobalISel\" OFF)\n    \n    option(LLVM_ENABLE_DAGISEL_COV \"Debug: Prints tablegen patterns that were used for selecting\" OFF)\n    \n    # Generate a CompilationDatabase (compile_commands.json file) for our build,\n    # for use by clang_complete, YouCompleteMe, etc.\n    set(CMAKE_EXPORT_COMPILE_COMMANDS 1)\n    \n    option(LLVM_INSTALL_UTILS \"Include utility binaries in the 'install' target.\" OFF)\n    \n    option(LLVM_INSTALL_TOOLCHAIN_ONLY \"Only include toolchain files in the 'install' target.\" OFF)\n    \n    option(LLVM_USE_FOLDERS \"Enable solution folders in Visual Studio. Disable for Express versions.\" ON)\n    if ( LLVM_USE_FOLDERS )\n      set_property(GLOBAL PROPERTY USE_FOLDERS ON)\n    endif()\n    \n    set(LLVM_ALL_TARGETS\n      AArch64\n      AMDGPU\n      ARM\n      BPF\n      Hexagon\n      Lanai\n      Mips\n      MSP430\n      NVPTX\n      PowerPC\n      RISCV\n      Sparc\n      SystemZ\n      X86\n      XCore\n      )\n    \n    # List of targets with JIT support:\n    set(LLVM_TARGETS_WITH_JIT X86 PowerPC AArch64 ARM Mips SystemZ)\n    \n    set(LLVM_TARGETS_TO_BUILD \"all\"\n        CACHE STRING \"Semicolon-separated list of targets to build, or \\\"all\\\".\")\n    \n    set(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD \"\"\n      CACHE STRING \"Semicolon-separated list of experimental targets to build.\")\n    \n    option(BUILD_SHARED_LIBS\n      \"Build all libraries as shared libraries instead of static\" OFF)\n    \n    option(LLVM_ENABLE_BACKTRACES \"Enable embedding backtraces on crash.\" ON)\n    if(LLVM_ENABLE_BACKTRACES)\n      set(ENABLE_BACKTRACES 1)\n    endif()\n    \n    option(LLVM_ENABLE_CRASH_OVERRIDES \"Enable crash overrides.\" ON)\n    if(LLVM_ENABLE_CRASH_OVERRIDES)\n      set(ENABLE_CRASH_OVERRIDES 1)\n    endif()\n    \n    option(LLVM_ENABLE_FFI \"Use libffi to call external functions from the interpreter\" OFF)\n    set(FFI_LIBRARY_DIR \"\" CACHE PATH \"Additional directory, where CMake should search for libffi.so\")\n    set(FFI_INCLUDE_DIR \"\" CACHE PATH \"Additional directory, where CMake should search for ffi.h or ffi\/ffi.h\")\n    \n    set(LLVM_TARGET_ARCH \"host\"\n      CACHE STRING \"Set target to use for LLVM JIT or use \\\"host\\\" for automatic detection.\")\n    \n    option(LLVM_ENABLE_TERMINFO \"Use terminfo database if available.\" ON)\n    \n    option(LLVM_ENABLE_LIBEDIT \"Use libedit if available.\" ON)\n    \n    option(LLVM_ENABLE_THREADS \"Use threads if available.\" ON)\n    \n    option(LLVM_ENABLE_ZLIB \"Use zlib for compression\/decompression if available.\" ON)\n    \n    if( LLVM_TARGETS_TO_BUILD STREQUAL \"all\" )\n      set( LLVM_TARGETS_TO_BUILD ${LLVM_ALL_TARGETS} )\n    endif()\n    \n    set(LLVM_TARGETS_TO_BUILD\n       ${LLVM_TARGETS_TO_BUILD}\n       ${LLVM_EXPERIMENTAL_TARGETS_TO_BUILD})\n    list(REMOVE_DUPLICATES LLVM_TARGETS_TO_BUILD)\n    \n    option(LLVM_ENABLE_PIC \"Build Position-Independent Code\" ON)\n    option(LLVM_ENABLE_WARNINGS \"Enable compiler warnings.\" ON)\n    option(LLVM_ENABLE_MODULES \"Compile with C++ modules enabled.\" OFF)\n    if(${CMAKE_SYSTEM_NAME} MATCHES \"Darwin\")\n      option(LLVM_ENABLE_MODULE_DEBUGGING \"Compile with -gmodules.\" ON)\n      option(LLVM_ENABLE_LOCAL_SUBMODULE_VISIBILITY \"Compile with -fmodules-local-submodule-visibility.\" OFF)\n    else()\n      option(LLVM_ENABLE_MODULE_DEBUGGING \"Compile with -gmodules.\" OFF)\n      option(LLVM_ENABLE_LOCAL_SUBMODULE_VISIBILITY \"Compile with -fmodules-local-submodule-visibility.\" ON)\n    endif()\n    option(LLVM_ENABLE_CXX1Y \"Compile with C++1y enabled.\" OFF)\n    option(LLVM_ENABLE_LIBCXX \"Use libc++ if available.\" OFF)\n    option(LLVM_ENABLE_LLD \"Use lld as C and C++ linker.\" OFF)\n    option(LLVM_ENABLE_PEDANTIC \"Compile with pedantic enabled.\" ON)\n    option(LLVM_ENABLE_WERROR \"Fail and stop if a warning is triggered.\" OFF)\n    \n    if( NOT uppercase_CMAKE_BUILD_TYPE STREQUAL \"DEBUG\" )\n      option(LLVM_ENABLE_ASSERTIONS \"Enable assertions\" OFF)\n    else()\n      option(LLVM_ENABLE_ASSERTIONS \"Enable assertions\" ON)\n    endif()\n    \n    option(LLVM_ENABLE_EXPENSIVE_CHECKS \"Enable expensive checks\" OFF)\n    \n    set(LLVM_ABI_BREAKING_CHECKS \"WITH_ASSERTS\" CACHE STRING\n      \"Enable abi-breaking checks.  Can be WITH_ASSERTS, FORCE_ON or FORCE_OFF.\")\n    \n    option(LLVM_FORCE_USE_OLD_HOST_TOOLCHAIN\n           \"Set to ON to force using an old, unsupported host toolchain.\" OFF)\n    \n    option(LLVM_USE_INTEL_JITEVENTS\n      \"Use Intel JIT API to inform Intel(R) VTune(TM) Amplifier XE 2011 about JIT code\"\n      OFF)\n    \n    if( LLVM_USE_INTEL_JITEVENTS )\n      # Verify we are on a supported platform\n      if( NOT CMAKE_SYSTEM_NAME MATCHES \"Windows\" AND NOT CMAKE_SYSTEM_NAME MATCHES \"Linux\" )\n        message(FATAL_ERROR\n          \"Intel JIT API support is available on Linux and Windows only.\")\n      endif()\n    endif( LLVM_USE_INTEL_JITEVENTS )\n    \n    option(LLVM_USE_OPROFILE\n      \"Use opagent JIT interface to inform OProfile about JIT code\" OFF)\n    \n    option(LLVM_EXTERNALIZE_DEBUGINFO\n      \"Generate dSYM files and strip executables and libraries (Darwin Only)\" OFF)\n    \n    # If enabled, verify we are on a platform that supports oprofile.\n    if( LLVM_USE_OPROFILE )\n      if( NOT CMAKE_SYSTEM_NAME MATCHES \"Linux\" )\n        message(FATAL_ERROR \"OProfile support is available on Linux only.\")\n      endif( NOT CMAKE_SYSTEM_NAME MATCHES \"Linux\" )\n    endif( LLVM_USE_OPROFILE )\n    \n    set(LLVM_USE_SANITIZER \"\" CACHE STRING\n      \"Define the sanitizer used to build binaries and tests.\")\n    \n    option(LLVM_USE_SPLIT_DWARF\n      \"Use -gsplit-dwarf when compiling llvm.\" OFF)\n    \n    option(LLVM_POLLY_LINK_INTO_TOOLS \"Statically link Polly into tools (if available)\" ON)\n    option(LLVM_POLLY_BUILD \"Build LLVM with Polly\" ON)\n    \n    #if (EXISTS ${SDIR}\/tools\/polly\/CMakeLists.txt)\n      set(POLLY_IN_TREE TRUE)\n    #elseif(LLVM_EXTERNAL_POLLY_SOURCE_DIR)\n    #  set(POLLY_IN_TREE TRUE)\n    #else()\n    #  set(POLLY_IN_TREE FALSE)\n    #endif()\n    \n    #if (LLVM_POLLY_BUILD AND POLLY_IN_TREE)\n      set(WITH_POLLY ON)\n    #else()\n    #  set(WITH_POLLY OFF)\n    #endif()\n    \n    #if (LLVM_POLLY_LINK_INTO_TOOLS AND WITH_POLLY)\n      set(LINK_POLLY_INTO_TOOLS ON)\n    #else()\n    #  set(LINK_POLLY_INTO_TOOLS OFF)\n    #endif()\n    \n    # Define an option controlling whether we should build for 32-bit on 64-bit\n    # platforms, where supported.\n    if( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT WIN32 )\n      # TODO: support other platforms and toolchains.\n      option(LLVM_BUILD_32_BITS \"Build 32 bits executables and libraries.\" OFF)\n    endif()\n    \n    # Define the default arguments to use with 'lit', and an option for the user to\n    # override.\n    set(LIT_ARGS_DEFAULT \"-sv\")\n    if (MSVC_IDE OR XCODE)\n      set(LIT_ARGS_DEFAULT \"${LIT_ARGS_DEFAULT} --no-progress-bar\")\n    endif()\n    set(LLVM_LIT_ARGS \"${LIT_ARGS_DEFAULT}\" CACHE STRING \"Default options for lit\")\n    \n    # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.\n    if( WIN32 AND NOT CYGWIN )\n      set(LLVM_LIT_TOOLS_DIR \"\" CACHE PATH \"Path to GnuWin32 tools\")\n    endif()\n    \n    # Define options to control the inclusion and default build behavior for\n    # components which may not strictly be necessary (tools, examples, and tests).\n    #\n    # This is primarily to support building smaller or faster project files.\n    option(LLVM_INCLUDE_TOOLS \"Generate build targets for the LLVM tools.\" ON)\n    option(LLVM_BUILD_TOOLS\n      \"Build the LLVM tools. If OFF, just generate build targets.\" ON)\n    \n    option(LLVM_INCLUDE_UTILS \"Generate build targets for the LLVM utils.\" ON)\n    option(LLVM_BUILD_UTILS\n      \"Build LLVM utility binaries. If OFF, just generate build targets.\" ON)\n    \n    option(LLVM_INCLUDE_RUNTIMES \"Generate build targets for the LLVM runtimes.\" ON)\n    option(LLVM_BUILD_RUNTIMES\n      \"Build the LLVM runtimes. If OFF, just generate build targets.\" ON)\n    \n    option(LLVM_BUILD_RUNTIME\n      \"Build the LLVM runtime libraries.\" ON)\n    option(LLVM_BUILD_EXAMPLES\n      \"Build the LLVM example programs. If OFF, just generate build targets.\" OFF)\n    option(LLVM_INCLUDE_EXAMPLES \"Generate build targets for the LLVM examples\" ON)\n    \n    option(LLVM_BUILD_TESTS\n      \"Build LLVM unit tests. If OFF, just generate build targets.\" OFF)\n    option(LLVM_INCLUDE_TESTS \"Generate build targets for the LLVM unit tests.\" ON)\n    option(LLVM_INCLUDE_GO_TESTS \"Include the Go bindings tests in test build targets.\" ON)\n    \n    option (LLVM_BUILD_DOCS \"Build the llvm documentation.\" OFF)\n    option (LLVM_INCLUDE_DOCS \"Generate build targets for llvm documentation.\" ON)\n    option (LLVM_ENABLE_DOXYGEN \"Use doxygen to generate llvm API documentation.\" OFF)\n    option (LLVM_ENABLE_SPHINX \"Use Sphinx to generate llvm documentation.\" OFF)\n    option (LLVM_ENABLE_OCAMLDOC \"Build OCaml bindings documentation.\" ON)\n    \n    set(LLVM_INSTALL_DOXYGEN_HTML_DIR \"share\/doc\/llvm\/doxygen-html\"\n        CACHE STRING \"Doxygen-generated HTML documentation install directory\")\n    set(LLVM_INSTALL_OCAMLDOC_HTML_DIR \"share\/doc\/llvm\/ocaml-html\"\n        CACHE STRING \"OCamldoc-generated HTML documentation install directory\")\n    \n    option (LLVM_BUILD_EXTERNAL_COMPILER_RT\n      \"Build compiler-rt as an external project.\" OFF)\n    \n    option (LLVM_VERSION_PRINTER_SHOW_HOST_TARGET_INFO\n      \"Show target and host info when tools are invoked with --version.\" ON)\n    \n    # You can configure which libraries from LLVM you want to include in the\n    # shared library by setting LLVM_DYLIB_COMPONENTS to a semi-colon delimited\n    # list of LLVM components. All component names handled by llvm-config are valid.\n    if(NOT DEFINED LLVM_DYLIB_COMPONENTS)\n      set(LLVM_DYLIB_COMPONENTS \"all\" CACHE STRING\n        \"Semicolon-separated list of components to include in libLLVM, or \\\"all\\\".\")\n    endif()\n    option(LLVM_LINK_LLVM_DYLIB \"Link tools against the libllvm dynamic library\" OFF)\n    option(LLVM_BUILD_LLVM_C_DYLIB \"Build libllvm-c re-export library (Darwin Only)\" OFF)\n    set(LLVM_BUILD_LLVM_DYLIB_default OFF)\n    if(LLVM_LINK_LLVM_DYLIB OR LLVM_BUILD_LLVM_C_DYLIB)\n      set(LLVM_BUILD_LLVM_DYLIB_default ON)\n    endif()\n    option(LLVM_BUILD_LLVM_DYLIB \"Build libllvm dynamic library\" ${LLVM_BUILD_LLVM_DYLIB_default})\n    \n    option(LLVM_DYLIB_SYMBOL_VERSIONING OFF)\n    \n    option(LLVM_OPTIMIZED_TABLEGEN \"Force TableGen to be built with optimization\" OFF)\n    if(CMAKE_CROSSCOMPILING OR (LLVM_OPTIMIZED_TABLEGEN AND (LLVM_ENABLE_ASSERTIONS OR CMAKE_CONFIGURATION_TYPES)))\n      set(LLVM_USE_HOST_TOOLS ON)\n    endif()\n    \n    if (MSVC_IDE AND NOT (MSVC_VERSION LESS 1900))\n      option(LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION \"Configure project to use Visual Studio native visualizers\" TRUE)\n    else()\n      set(LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION FALSE CACHE INTERNAL \"For Visual Studio 2013, manually copy natvis files to Documents\\\\Visual Studio 2013\\\\Visualizers\" FORCE)\n    endif()\n    \n    if (LLVM_BUILD_INSTRUMENTED OR LLVM_BUILD_INSTRUMENTED_COVERAGE)\n      if(NOT LLVM_PROFILE_MERGE_POOL_SIZE)\n        # A pool size of 1-2 is probably sufficient on a SSD. 3-4 should be fine\n        # for spining disks. Anything higher may only help on slower mediums.\n        set(LLVM_PROFILE_MERGE_POOL_SIZE \"4\")\n      endif()\n      if(NOT LLVM_PROFILE_FILE_PATTERN)\n        if(NOT LLVM_PROFILE_DATA_DIR)\n          file(TO_NATIVE_PATH \"${LLVM_BINARY_DIR}\/profiles\/%${LLVM_PROFILE_MERGE_POOL_SIZE}m.profraw\" LLVM_PROFILE_FILE_PATTERN)\n        else()\n          file(TO_NATIVE_PATH \"${LLVM_PROFILE_DATA_DIR}\/%${LLVM_PROFILE_MERGE_POOL_SIZE}m.profraw\" LLVM_PROFILE_FILE_PATTERN)\n        endif()\n      endif()\n    endif()\n    \n    if (LLVM_BUILD_STATIC)\n      set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -static\")\n    endif()\n    \n    # All options referred to from HandleLLVMOptions have to be specified\n    # BEFORE this include, otherwise options will not be correctly set on\n    # first cmake run\n    if( WIN32 AND NOT CYGWIN )\n      # We consider Cygwin as another Unix\n      set(PURE_WINDOWS 1)\n    endif()\n    \n    include(CheckIncludeFile)\n    include(CheckIncludeFileCXX)\n    include(CheckLibraryExists)\n    include(CheckSymbolExists)\n    include(CheckFunctionExists)\n    include(CheckCXXSourceCompiles)\n    include(TestBigEndian)\n    \n    # Check if the host compiler is new enough. LLVM requires at least GCC 4.8,\n    # MSVC 2015 (Update 3), or Clang 3.1.\n    \n    include(CheckCXXSourceCompiles)\n    \n    if(NOT DEFINED LLVM_COMPILER_CHECKED)\n      set(LLVM_COMPILER_CHECKED ON)\n    \n      if(NOT LLVM_FORCE_USE_OLD_TOOLCHAIN)\n        if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n          if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 4.8)\n            message(FATAL_ERROR \"Host GCC version must be at least 4.8!\")\n          endif()\n        elseif(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n          if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 3.1)\n            message(FATAL_ERROR \"Host Clang version must be at least 3.1!\")\n          endif()\n    \n          if (CMAKE_CXX_SIMULATE_ID MATCHES \"MSVC\")\n            if (CMAKE_CXX_SIMULATE_VERSION VERSION_LESS 19.0)\n              message(FATAL_ERROR \"Host Clang must have at least -fms-compatibility-version=19.0\")\n            endif()\n            set(CLANG_CL 1)\n          elseif(NOT LLVM_ENABLE_LIBCXX)\n            # Otherwise, test that we aren't using too old of a version of libstdc++\n            # with the Clang compiler. This is tricky as there is no real way to\n            # check the version of libstdc++ directly. Instead we test for a known\n            # bug in libstdc++4.6 that is fixed in libstdc++4.7.\n            set(OLD_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})\n            set(OLD_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})\n            set(CMAKE_REQUIRED_FLAGS \"-std=c++0x\")\n            check_cxx_source_compiles(\"\n    #include <atomic>\n    std::atomic<float> x(0.0f);\n    int main() { return (float)x; }\"\n              LLVM_NO_OLD_LIBSTDCXX)\n            if(NOT LLVM_NO_OLD_LIBSTDCXX)\n              message(FATAL_ERROR \"Host Clang must be able to find libstdc++4.8 or newer!\")\n            endif()\n            set(CMAKE_REQUIRED_FLAGS ${OLD_CMAKE_REQUIRED_FLAGS})\n            set(CMAKE_REQUIRED_LIBRARIES ${OLD_CMAKE_REQUIRED_LIBRARIES})\n          endif()\n        elseif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n          if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 19.0)\n            message(FATAL_ERROR \"Host Visual Studio must be at least 2015\")\n          elseif(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 19.00.24213.1)\n            message(WARNING \"Host Visual Studio should at least be 2015 Update 3 (MSVC 19.00.24213.1)\"\n              \"  due to miscompiles from earlier versions\")\n          endif()\n        endif()\n      endif()\n    endif()\n    \n    # This CMake module is responsible for setting the standard library to libc++\n    # if the user has requested it.\n    \n    # Determine if the compiler has GCC-compatible command-line syntax.\n    \n    if(NOT DEFINED LLVM_COMPILER_IS_GCC_COMPATIBLE)\n      if(CMAKE_COMPILER_IS_GNUCXX)\n        set(LLVM_COMPILER_IS_GCC_COMPATIBLE ON)\n      elseif( MSVC )\n        set(LLVM_COMPILER_IS_GCC_COMPATIBLE OFF)\n      elseif( \"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"Clang\" )\n        set(LLVM_COMPILER_IS_GCC_COMPATIBLE ON)\n      elseif( \"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"Intel\" )\n        set(LLVM_COMPILER_IS_GCC_COMPATIBLE ON)\n      endif()\n    endif()\n    \n    \n    if(NOT DEFINED LLVM_STDLIB_HANDLED)\n      set(LLVM_STDLIB_HANDLED ON)\n    \n      function(append value)\n        foreach(variable ${ARGN})\n          set(${variable} \"${${variable}} ${value}\" PARENT_SCOPE)\n        endforeach(variable)\n      endfunction()\n    \n      include(CheckCXXCompilerFlag)\n      if(LLVM_ENABLE_LIBCXX)\n        if(LLVM_COMPILER_IS_GCC_COMPATIBLE)\n          check_cxx_compiler_flag(\"-stdlib=libc++\" CXX_SUPPORTS_STDLIB)\n          if(CXX_SUPPORTS_STDLIB)\n            append(\"-stdlib=libc++\"\n              CMAKE_CXX_FLAGS CMAKE_EXE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS\n              CMAKE_MODULE_LINKER_FLAGS)\n          else()\n            message(WARNING \"Can't specify libc++ with '-stdlib='\")\n          endif()\n        else()\n          message(WARNING \"Not sure how to specify libc++ for this compiler\")\n        endif()\n      endif()\n    endif()\n    \n    \n    if( UNIX AND NOT (BEOS OR HAIKU) )\n      # Used by check_symbol_exists:\n      set(CMAKE_REQUIRED_LIBRARIES m)\n    endif()\n    # x86_64 FreeBSD 9.2 requires libcxxrt to be specified explicitly.\n    if( CMAKE_SYSTEM MATCHES \"FreeBSD-9.2-RELEASE\" AND\n        CMAKE_SIZEOF_VOID_P EQUAL 8 )\n      list(APPEND CMAKE_REQUIRED_LIBRARIES \"cxxrt\")\n    endif()\n    \n    # Helper macros and functions\n    macro(add_cxx_include result files)\n      set(${result} \"\")\n      foreach (file_name ${files})\n         set(${result} \"${${result}}#include<${file_name}>\\n\")\n      endforeach()\n    endmacro(add_cxx_include files result)\n    \n    function(check_type_exists type files variable)\n      add_cxx_include(includes \"${files}\")\n      CHECK_CXX_SOURCE_COMPILES(\"\n        ${includes} ${type} typeVar;\n        int main() {\n            return 0;\n        }\n        \" ${variable})\n    endfunction()\n    \n    # library checks\n    if( NOT PURE_WINDOWS )\n      check_library_exists(pthread pthread_create \"\" HAVE_LIBPTHREAD)\n      if (HAVE_LIBPTHREAD)\n        check_library_exists(pthread pthread_getspecific \"\" HAVE_PTHREAD_GETSPECIFIC)\n        check_library_exists(pthread pthread_rwlock_init \"\" HAVE_PTHREAD_RWLOCK_INIT)\n        check_library_exists(pthread pthread_mutex_lock \"\" HAVE_PTHREAD_MUTEX_LOCK)\n      else()\n        # this could be Android\n        check_library_exists(c pthread_create \"\" PTHREAD_IN_LIBC)\n        if (PTHREAD_IN_LIBC)\n          check_library_exists(c pthread_getspecific \"\" HAVE_PTHREAD_GETSPECIFIC)\n          check_library_exists(c pthread_rwlock_init \"\" HAVE_PTHREAD_RWLOCK_INIT)\n          check_library_exists(c pthread_mutex_lock \"\" HAVE_PTHREAD_MUTEX_LOCK)\n        endif()\n      endif()\n      check_library_exists(dl dlopen \"\" HAVE_LIBDL)\n      check_library_exists(rt clock_gettime \"\" HAVE_LIBRT)\n    endif()\n    \n    if( LLVM_USING_GLIBC )\n      add_definitions( -D_GNU_SOURCE )\n    endif()\n    # This check requires _GNU_SOURCE\n    if(HAVE_LIBPTHREAD)\n      check_library_exists(pthread pthread_getname_np \"\" HAVE_PTHREAD_GETNAME_NP)\n      check_library_exists(pthread pthread_setname_np \"\" HAVE_PTHREAD_SETNAME_NP)\n    elseif(PTHREAD_IN_LIBC)\n      check_library_exists(c pthread_getname_np \"\" HAVE_PTHREAD_GETNAME_NP)\n      check_library_exists(c pthread_setname_np \"\" HAVE_PTHREAD_SETNAME_NP)\n    endif()\n    \n    if(HAVE_LIBPTHREAD)\n      # We want to find pthreads library and at the moment we do want to\n      # have it reported as '-l<lib>' instead of '-pthread'.\n      # TODO: switch to -pthread once the rest of the build system can deal with it.\n      set(CMAKE_THREAD_PREFER_PTHREAD TRUE)\n      set(THREADS_HAVE_PTHREAD_ARG Off)\n      find_package(Threads REQUIRED)\n      set(LLVM_PTHREAD_LIB ${CMAKE_THREAD_LIBS_INIT})\n    endif()\n    \n    if (APPLE)\n      CHECK_C_SOURCE_COMPILES(\"\n         static const char *__crashreporter_info__ = 0;\n         asm(\\\".desc ___crashreporter_info__, 0x10\\\");\n         int main() { return 0; }\"\n        HAVE_CRASHREPORTER_INFO)\n    endif()\n    \n    # Don't look for these libraries on Windows. Also don't look for them if we're\n    # using MSan, since uninstrumented third party code may call MSan interceptors\n    # like strlen, leading to false positives.\n    if( NOT PURE_WINDOWS AND NOT LLVM_USE_SANITIZER MATCHES \"Memory.*\")\n        set(HAVE_LIBZ 1)\n      # Skip libedit if using ASan as it contains memory leaks.\n      if (LLVM_ENABLE_LIBEDIT AND HAVE_HISTEDIT_H AND NOT LLVM_USE_SANITIZER MATCHES \".*Address.*\")\n        check_library_exists(edit el_init \"\" HAVE_LIBEDIT)\n      else()\n        set(HAVE_LIBEDIT 0)\n      endif()\n      if(LLVM_ENABLE_TERMINFO)\n        set(HAVE_TERMINFO 0)\n        foreach(library tinfo terminfo curses ncurses ncursesw)\n          string(TOUPPER ${library} library_suffix)\n          check_library_exists(${library} setupterm \"\" HAVE_TERMINFO_${library_suffix})\n          if(HAVE_TERMINFO_${library_suffix})\n            set(HAVE_TERMINFO 1)\n            set(TERMINFO_LIBS \"${library}\")\n            break()\n          endif()\n        endforeach()\n      else()\n        set(HAVE_TERMINFO 0)\n      endif()\n    endif()\n    \n    check_library_exists(xar xar_open \"\" HAVE_LIBXAR)\n    if(HAVE_LIBXAR)\n      set(XAR_LIB xar)\n    endif()\n    \n    # available programs checks\n    function(llvm_find_program name)\n      string(TOUPPER ${name} NAME)\n      string(REGEX REPLACE \"\\\\.\" \"_\" NAME ${NAME})\n    \n      find_program(LLVM_PATH_${NAME} NAMES ${ARGV})\n      mark_as_advanced(LLVM_PATH_${NAME})\n      if(LLVM_PATH_${NAME})\n        set(HAVE_${NAME} 1 CACHE INTERNAL \"Is ${name} available ?\")\n        mark_as_advanced(HAVE_${NAME})\n      else(LLVM_PATH_${NAME})\n        set(HAVE_${NAME} \"\" CACHE INTERNAL \"Is ${name} available ?\")\n      endif(LLVM_PATH_${NAME})\n    endfunction()\n    \n    if (LLVM_ENABLE_DOXYGEN)\n      llvm_find_program(dot)\n    endif ()\n    \n    if( LLVM_ENABLE_FFI )\n      find_path(FFI_INCLUDE_PATH ffi.h PATHS ${FFI_INCLUDE_DIR})\n      if( EXISTS \"${FFI_INCLUDE_PATH}\/ffi.h\" )\n        set(FFI_HEADER ffi.h CACHE INTERNAL \"\")\n        set(HAVE_FFI_H 1 CACHE INTERNAL \"\")\n      else()\n        find_path(FFI_INCLUDE_PATH ffi\/ffi.h PATHS ${FFI_INCLUDE_DIR})\n        if( EXISTS \"${FFI_INCLUDE_PATH}\/ffi\/ffi.h\" )\n          set(FFI_HEADER ffi\/ffi.h CACHE INTERNAL \"\")\n          set(HAVE_FFI_FFI_H 1 CACHE INTERNAL \"\")\n        endif()\n      endif()\n    \n      if( NOT FFI_HEADER )\n        message(FATAL_ERROR \"libffi includes are not found.\")\n      endif()\n    \n      find_library(FFI_LIBRARY_PATH ffi PATHS ${FFI_LIBRARY_DIR})\n      if( NOT FFI_LIBRARY_PATH )\n        message(FATAL_ERROR \"libffi is not found.\")\n      endif()\n    \n      list(APPEND CMAKE_REQUIRED_LIBRARIES ${FFI_LIBRARY_PATH})\n      list(APPEND CMAKE_REQUIRED_INCLUDES ${FFI_INCLUDE_PATH})\n      check_symbol_exists(ffi_call ${FFI_HEADER} HAVE_FFI_CALL)\n      list(REMOVE_ITEM CMAKE_REQUIRED_INCLUDES ${FFI_INCLUDE_PATH})\n      list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES ${FFI_LIBRARY_PATH})\n    else()\n      unset(HAVE_FFI_FFI_H CACHE)\n      unset(HAVE_FFI_H CACHE)\n      unset(HAVE_FFI_CALL CACHE)\n    endif( LLVM_ENABLE_FFI )\n    \n    # Define LLVM_HAS_ATOMICS if gcc or MSVC atomic builtins are supported.\n    \n    # atomic builtins are required for threading support.\n    \n    INCLUDE(CheckCXXSourceCompiles)\n    \n    # Sometimes linking against libatomic is required for atomic ops, if\n    # the platform doesn't support lock-free atomics.\n    \n    function(check_working_cxx_atomics varname)\n      set(OLD_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})\n      set(CMAKE_REQUIRED_FLAGS \"-std=c++11\")\n      CHECK_CXX_SOURCE_COMPILES(\"\n    #include <atomic>\n    std::atomic<int> x;\n    int main() {\n      return x;\n    }\n    \" ${varname})\n      set(CMAKE_REQUIRED_FLAGS ${OLD_CMAKE_REQUIRED_FLAGS})\n    endfunction(check_working_cxx_atomics)\n    \n    function(check_working_cxx_atomics64 varname)\n      set(OLD_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})\n      set(CMAKE_REQUIRED_FLAGS \"-std=c++11 ${CMAKE_REQUIRED_FLAGS}\")\n      CHECK_CXX_SOURCE_COMPILES(\"\n    #include <atomic>\n    #include <cstdint>\n    std::atomic<uint64_t> x (0);\n    int main() {\n      uint64_t i = x.load(std::memory_order_relaxed);\n      return 0;\n    }\n    \" ${varname})\n      set(CMAKE_REQUIRED_FLAGS ${OLD_CMAKE_REQUIRED_FLAGS})\n    endfunction(check_working_cxx_atomics64)\n    \n    \n    # This isn't necessary on MSVC, so avoid command-line switch annoyance\n    # by only running on GCC-like hosts.\n    if (LLVM_COMPILER_IS_GCC_COMPATIBLE)\n      # First check if atomics work without the library.\n      check_working_cxx_atomics(HAVE_CXX_ATOMICS_WITHOUT_LIB)\n      # If not, check if the library exists, and atomics work with it.\n      if(NOT HAVE_CXX_ATOMICS_WITHOUT_LIB)\n        check_library_exists(atomic __atomic_fetch_add_4 \"\" HAVE_LIBATOMIC)\n        if( HAVE_LIBATOMIC )\n          list(APPEND CMAKE_REQUIRED_LIBRARIES \"atomic\")\n          check_working_cxx_atomics(HAVE_CXX_ATOMICS_WITH_LIB)\n          if (NOT HAVE_CXX_ATOMICS_WITH_LIB)\n        message(FATAL_ERROR \"Host compiler must support std::atomic!\")\n          endif()\n        else()\n          message(FATAL_ERROR \"Host compiler appears to require libatomic, but cannot find it.\")\n        endif()\n      endif()\n    endif()\n    \n    # Check for 64 bit atomic operations.\n    if(MSVC)\n      set(HAVE_CXX_ATOMICS64_WITHOUT_LIB True)\n    else()\n      check_working_cxx_atomics64(HAVE_CXX_ATOMICS64_WITHOUT_LIB)\n    endif()\n    \n    # If not, check if the library exists, and atomics work with it.\n    if(NOT HAVE_CXX_ATOMICS64_WITHOUT_LIB)\n      check_library_exists(atomic __atomic_load_8 \"\" HAVE_CXX_LIBATOMICS64)\n      if(HAVE_CXX_LIBATOMICS64)\n        list(APPEND CMAKE_REQUIRED_LIBRARIES \"atomic\")\n        check_working_cxx_atomics64(HAVE_CXX_ATOMICS64_WITH_LIB)\n        if (NOT HAVE_CXX_ATOMICS64_WITH_LIB)\n          message(FATAL_ERROR \"Host compiler must support std::atomic!\")\n        endif()\n      else()\n        message(FATAL_ERROR \"Host compiler appears to require libatomic, but cannot find it.\")\n      endif()\n    endif()\n    \n    ## TODO: This define is only used for the legacy atomic operations in\n    ## llvm's Atomic.h, which should be replaced.  Other code simply\n    ## assumes C++11 <atomic> works.\n    CHECK_CXX_SOURCE_COMPILES(\"\n    #ifdef _MSC_VER\n    #include <Intrin.h> \/* Workaround for PR19898. *\/\n    #include <windows.h>\n    #endif\n    int main() {\n    #ifdef _MSC_VER\n            volatile LONG val = 1;\n            MemoryBarrier();\n            InterlockedCompareExchange(&val, 0, 1);\n            InterlockedIncrement(&val);\n            InterlockedDecrement(&val);\n    #else\n            volatile unsigned long val = 1;\n            __sync_synchronize();\n            __sync_val_compare_and_swap(&val, 1, 0);\n            __sync_add_and_fetch(&val, 1);\n            __sync_sub_and_fetch(&val, 1);\n    #endif\n            return 0;\n          }\n    \" LLVM_HAS_ATOMICS)\n    \n    if( NOT LLVM_HAS_ATOMICS )\n      message(STATUS \"Warning: LLVM will be built thread-unsafe because atomic builtins are missing\")\n    endif()\n    \n    \n    \n    if( LLVM_ENABLE_PIC )\n      set(ENABLE_PIC 1)\n    else()\n      set(ENABLE_PIC 0)\n      check_cxx_compiler_flag(\"-fno-pie\" SUPPORTS_NO_PIE_FLAG)\n      if(SUPPORTS_NO_PIE_FLAG)\n        set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fno-pie\")\n      endif()\n    endif()\n    \n    check_cxx_compiler_flag(\"-Wvariadic-macros\" SUPPORTS_VARIADIC_MACROS_FLAG)\n    check_cxx_compiler_flag(\"-Wgnu-zero-variadic-macro-arguments\"\n                            SUPPORTS_GNU_ZERO_VARIADIC_MACRO_ARGUMENTS_FLAG)\n    \n    set(USE_NO_MAYBE_UNINITIALIZED 0)\n    set(USE_NO_UNINITIALIZED 0)\n    \n    # Disable gcc's potentially uninitialized use analysis as it presents lots of\n    # false positives.\n    if (CMAKE_COMPILER_IS_GNUCXX)\n      check_cxx_compiler_flag(\"-Wmaybe-uninitialized\" HAS_MAYBE_UNINITIALIZED)\n      if (HAS_MAYBE_UNINITIALIZED)\n        set(USE_NO_MAYBE_UNINITIALIZED 1)\n      else()\n        # Only recent versions of gcc make the distinction between -Wuninitialized\n        # and -Wmaybe-uninitialized. If -Wmaybe-uninitialized isn't supported, just\n        # turn off all uninitialized use warnings.\n        check_cxx_compiler_flag(\"-Wuninitialized\" HAS_UNINITIALIZED)\n        set(USE_NO_UNINITIALIZED ${HAS_UNINITIALIZED})\n      endif()\n    endif()\n    \n    # By default, we target the host, but this can be overridden at CMake\n    # invocation time.\n    # Returns the host triple.\n    # Invokes config.guess\n    \n    function( get_host_triple var )\n      if( MSVC )\n        if( CMAKE_CL_64 )\n          set( value \"x86_64-pc-win32\" )\n        else()\n          set( value \"i686-pc-win32\" )\n        endif()\n      elseif( MINGW AND NOT MSYS )\n        if( CMAKE_SIZEOF_VOID_P EQUAL 8 )\n          set( value \"x86_64-w64-mingw32\" )\n        else()\n          set( value \"i686-pc-mingw32\" )\n        endif()\n      else( MSVC )\n        set(config_guess ${SDIR}\/cmake\/config.guess)\n        execute_process(COMMAND sh ${config_guess}\n          RESULT_VARIABLE TT_RV\n          OUTPUT_VARIABLE TT_OUT\n          OUTPUT_STRIP_TRAILING_WHITESPACE)\n        if( NOT TT_RV EQUAL 0 )\n          message(FATAL_ERROR \"Failed to execute ${config_guess}\")\n        endif( NOT TT_RV EQUAL 0 )\n        set( value ${TT_OUT} )\n      endif( MSVC )\n      set( ${var} ${value} PARENT_SCOPE )\n    endfunction( get_host_triple var )\n    \n    get_host_triple(LLVM_INFERRED_HOST_TRIPLE)\n    \n    set(LLVM_HOST_TRIPLE \"${LLVM_INFERRED_HOST_TRIPLE}\" CACHE STRING\n        \"Host on which LLVM binaries will run\")\n    \n    # Determine the native architecture.\n    string(TOLOWER \"${LLVM_TARGET_ARCH}\" LLVM_NATIVE_ARCH)\n    if( LLVM_NATIVE_ARCH STREQUAL \"host\" )\n      string(REGEX MATCH \"^[^-]*\" LLVM_NATIVE_ARCH ${LLVM_HOST_TRIPLE})\n    endif ()\n    \n    if (LLVM_NATIVE_ARCH MATCHES \"i[2-6]86\")\n      set(LLVM_NATIVE_ARCH X86)\n    elseif (LLVM_NATIVE_ARCH STREQUAL \"x86\")\n      set(LLVM_NATIVE_ARCH X86)\n    elseif (LLVM_NATIVE_ARCH STREQUAL \"amd64\")\n      set(LLVM_NATIVE_ARCH X86)\n    elseif (LLVM_NATIVE_ARCH STREQUAL \"x86_64\")\n      set(LLVM_NATIVE_ARCH X86)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"sparc\")\n      set(LLVM_NATIVE_ARCH Sparc)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"powerpc\")\n      set(LLVM_NATIVE_ARCH PowerPC)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"aarch64\")\n      set(LLVM_NATIVE_ARCH AArch64)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"arm64\")\n      set(LLVM_NATIVE_ARCH AArch64)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"arm\")\n      set(LLVM_NATIVE_ARCH ARM)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"mips\")\n      set(LLVM_NATIVE_ARCH Mips)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"xcore\")\n      set(LLVM_NATIVE_ARCH XCore)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"msp430\")\n      set(LLVM_NATIVE_ARCH MSP430)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"hexagon\")\n      set(LLVM_NATIVE_ARCH Hexagon)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"s390x\")\n      set(LLVM_NATIVE_ARCH SystemZ)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"wasm32\")\n      set(LLVM_NATIVE_ARCH WebAssembly)\n    elseif (LLVM_NATIVE_ARCH MATCHES \"wasm64\")\n      set(LLVM_NATIVE_ARCH WebAssembly)\n    else ()\n      message(FATAL_ERROR \"Unknown architecture ${LLVM_NATIVE_ARCH}\")\n    endif ()\n    \n    # If build targets includes \"host\", then replace with native architecture.\n    list(FIND LLVM_TARGETS_TO_BUILD \"host\" idx)\n    if( NOT idx LESS 0 )\n      list(REMOVE_AT LLVM_TARGETS_TO_BUILD ${idx})\n      list(APPEND LLVM_TARGETS_TO_BUILD ${LLVM_NATIVE_ARCH})\n      list(REMOVE_DUPLICATES LLVM_TARGETS_TO_BUILD)\n    endif()\n    \n    list(FIND LLVM_TARGETS_TO_BUILD ${LLVM_NATIVE_ARCH} NATIVE_ARCH_IDX)\n    if (NATIVE_ARCH_IDX EQUAL -1)\n      #message(STATUS \"Native target ${LLVM_NATIVE_ARCH} is not selected; lli will not JIT code\")\n    else ()\n      #message(STATUS \"Native target architecture is ${LLVM_NATIVE_ARCH}\")\n      set(LLVM_NATIVE_TARGET LLVMInitialize${LLVM_NATIVE_ARCH}Target)\n      set(LLVM_NATIVE_TARGETINFO LLVMInitialize${LLVM_NATIVE_ARCH}TargetInfo)\n      set(LLVM_NATIVE_TARGETMC LLVMInitialize${LLVM_NATIVE_ARCH}TargetMC)\n      set(LLVM_NATIVE_ASMPRINTER LLVMInitialize${LLVM_NATIVE_ARCH}AsmPrinter)\n    \n      # We don't have an ASM parser for all architectures yet.\n      if (EXISTS ${SDIR}\/lib\/Target\/${LLVM_NATIVE_ARCH}\/AsmParser\/CMakeLists.txt)\n        set(LLVM_NATIVE_ASMPARSER LLVMInitialize${LLVM_NATIVE_ARCH}AsmParser)\n      endif ()\n    \n      # We don't have an disassembler for all architectures yet.\n      if (EXISTS ${SDIR}\/lib\/Target\/${LLVM_NATIVE_ARCH}\/Disassembler\/CMakeLists.txt)\n        set(LLVM_NATIVE_DISASSEMBLER LLVMInitialize${LLVM_NATIVE_ARCH}Disassembler)\n      endif ()\n    endif ()\n    \n    if( MINGW )\n      set(HAVE_LIBPSAPI 1)\n      set(HAVE_LIBSHELL32 1)\n      # TODO: Check existence of libraries.\n      #   include(CheckLibraryExists)\n    endif( MINGW )\n    \n    if (NOT HAVE_STRTOLL)\n      # Use _strtoi64 if strtoll is not available.\n      check_symbol_exists(_strtoi64 stdlib.h have_strtoi64)\n      if (have_strtoi64)\n        set(HAVE_STRTOLL 1)\n        set(strtoll \"_strtoi64\")\n        set(strtoull \"_strtoui64\")\n      endif ()\n    endif ()\n    \n    if( MSVC )\n      set(SHLIBEXT \".lib\")\n      set(stricmp \"_stricmp\")\n      set(strdup \"_strdup\")\n    \n      # See if the DIA SDK is available and usable.\n      set(MSVC_DIA_SDK_DIR \"$ENV{VSINSTALLDIR}DIA SDK\")\n    \n      # Due to a bug in MSVC 2013's installation software, it is possible\n      # for MSVC 2013 to write the DIA SDK into the Visual Studio 2012\n      # install directory.  If this happens, the installation is corrupt\n      # and there's nothing we can do.  It happens with enough frequency\n      # though that we should handle it.  We do so by simply checking that\n      # the DIA SDK folder exists.  Should this happen you will need to\n      # uninstall VS 2012 and then re-install VS 2013.\n      if (IS_DIRECTORY ${MSVC_DIA_SDK_DIR})\n        set(HAVE_DIA_SDK 1)\n      else()\n        set(HAVE_DIA_SDK 0)\n      endif()\n    \n      option(LLVM_ENABLE_DIA_SDK \"Use MSVC DIA SDK for debugging if available.\"\n                                 ${HAVE_DIA_SDK})\n    \n      if(LLVM_ENABLE_DIA_SDK AND NOT HAVE_DIA_SDK)\n        message(FATAL_ERROR \"DIA SDK not found. If you have both VS 2012 and 2013 installed, you may need to uninstall the former and re-install the latter afterwards.\")\n      endif()\n    else()\n      set(LLVM_ENABLE_DIA_SDK 0)\n    endif( MSVC )\n    \n    # FIXME: Signal handler return type, currently hardcoded to 'void'\n    set(RETSIGTYPE void)\n    \n    if( LLVM_ENABLE_THREADS )\n      # Check if threading primitives aren't supported on this platform\n      if( NOT HAVE_PTHREAD_H AND NOT WIN32 )\n        set(LLVM_ENABLE_THREADS 0)\n      endif()\n    endif()\n    \n    if( LLVM_ENABLE_THREADS )\n      #message(STATUS \"Threads enabled.\")\n    else( LLVM_ENABLE_THREADS )\n      #message(STATUS \"Threads disabled.\")\n    endif()\n    \n    if (LLVM_ENABLE_ZLIB )\n        set(LLVM_ENABLE_ZLIB 1)\n    endif()\n    \n    find_program(GOLD_EXECUTABLE NAMES ${LLVM_DEFAULT_TARGET_TRIPLE}-ld.gold ld.gold ${LLVM_DEFAULT_TARGET_TRIPLE}-ld ld DOC \"The gold linker\")\n    set(LLVM_BINUTILS_INCDIR \"\" CACHE PATH\n        \"PATH to binutils\/include containing plugin-api.h for gold plugin.\")\n    \n    if(CMAKE_HOST_APPLE AND APPLE)\n      if(NOT CMAKE_XCRUN)\n        find_program(CMAKE_XCRUN NAMES xcrun)\n      endif()\n      if(CMAKE_XCRUN)\n        execute_process(COMMAND ${CMAKE_XCRUN} -find ld\n          OUTPUT_VARIABLE LD64_EXECUTABLE\n          OUTPUT_STRIP_TRAILING_WHITESPACE)\n      else()\n        find_program(LD64_EXECUTABLE NAMES ld DOC \"The ld64 linker\")\n      endif()\n    \n      if(LD64_EXECUTABLE)\n        set(LD64_EXECUTABLE ${LD64_EXECUTABLE} CACHE PATH \"ld64 executable\")\n        message(STATUS \"Found ld64 - ${LD64_EXECUTABLE}\")\n      endif()\n    endif()\n    \n    string(REPLACE \" \" \";\" LLVM_BINDINGS_LIST \"${LLVM_BINDINGS}\")\n    \n    string(REPLACE \"Native\" ${LLVM_NATIVE_ARCH}\n      LLVM_TARGETS_TO_BUILD \"${LLVM_TARGETS_TO_BUILD}\")\n    list(REMOVE_DUPLICATES LLVM_TARGETS_TO_BUILD)\n    \n    # By default, we target the host, but this can be overridden at CMake\n    # invocation time.\n    set(LLVM_DEFAULT_TARGET_TRIPLE \"${LLVM_HOST_TRIPLE}\" CACHE STRING\n      \"Default target for which LLVM will generate code.\" )\n    set(TARGET_TRIPLE \"${LLVM_DEFAULT_TARGET_TRIPLE}\")\n    #message(STATUS \"LLVM host triple: ${LLVM_HOST_TRIPLE}\")\n    #message(STATUS \"LLVM default target triple: ${LLVM_DEFAULT_TARGET_TRIPLE}\")\n    \n    \n    # This CMake module is responsible for interpreting the user defined LLVM_\n    # options and executing the appropriate CMake commands to realize the users'\n    # selections.\n    \n    # This is commonly needed so make sure it's defined before we include anything\n    # else.\n    string(TOUPPER \"${CMAKE_BUILD_TYPE}\" uppercase_CMAKE_BUILD_TYPE)\n    \n    # Check if the host compiler is new enough. LLVM requires at least GCC 4.8,\n    # MSVC 2015 (Update 3), or Clang 3.1.\n    \n    include(CheckCXXSourceCompiles)\n    \n    if(NOT DEFINED LLVM_COMPILER_CHECKED)\n      set(LLVM_COMPILER_CHECKED ON)\n    \n      if(NOT LLVM_FORCE_USE_OLD_TOOLCHAIN)\n        if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n          if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 4.8)\n            message(FATAL_ERROR \"Host GCC version must be at least 4.8!\")\n          endif()\n        elseif(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n          if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 3.1)\n            message(FATAL_ERROR \"Host Clang version must be at least 3.1!\")\n          endif()\n    \n          if (CMAKE_CXX_SIMULATE_ID MATCHES \"MSVC\")\n            if (CMAKE_CXX_SIMULATE_VERSION VERSION_LESS 19.0)\n              message(FATAL_ERROR \"Host Clang must have at least -fms-compatibility-version=19.0\")\n            endif()\n            set(CLANG_CL 1)\n          elseif(NOT LLVM_ENABLE_LIBCXX)\n            # Otherwise, test that we aren't using too old of a version of libstdc++\n            # with the Clang compiler. This is tricky as there is no real way to\n            # check the version of libstdc++ directly. Instead we test for a known\n            # bug in libstdc++4.6 that is fixed in libstdc++4.7.\n            set(OLD_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})\n            set(OLD_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})\n            set(CMAKE_REQUIRED_FLAGS \"-std=c++0x\")\n            check_cxx_source_compiles(\"\n    #include <atomic>\n    std::atomic<float> x(0.0f);\n    int main() { return (float)x; }\"\n              LLVM_NO_OLD_LIBSTDCXX)\n            if(NOT LLVM_NO_OLD_LIBSTDCXX)\n              message(FATAL_ERROR \"Host Clang must be able to find libstdc++4.8 or newer!\")\n            endif()\n            set(CMAKE_REQUIRED_FLAGS ${OLD_CMAKE_REQUIRED_FLAGS})\n            set(CMAKE_REQUIRED_LIBRARIES ${OLD_CMAKE_REQUIRED_LIBRARIES})\n          endif()\n        elseif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n          if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 19.0)\n            message(FATAL_ERROR \"Host Visual Studio must be at least 2015\")\n          elseif(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 19.00.24213.1)\n            message(WARNING \"Host Visual Studio should at least be 2015 Update 3 (MSVC 19.00.24213.1)\"\n              \"  due to miscompiles from earlier versions\")\n          endif()\n        endif()\n      endif()\n    endif()\n    \n    \n    # This CMake module is responsible for setting the standard library to libc++\n    # if the user has requested it.\n    # Determine if the compiler has GCC-compatible command-line syntax.\n    \n    if(NOT DEFINED LLVM_COMPILER_IS_GCC_COMPATIBLE)\n      if(CMAKE_COMPILER_IS_GNUCXX)\n        set(LLVM_COMPILER_IS_GCC_COMPATIBLE ON)\n      elseif( MSVC )\n        set(LLVM_COMPILER_IS_GCC_COMPATIBLE OFF)\n      elseif( \"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"Clang\" )\n        set(LLVM_COMPILER_IS_GCC_COMPATIBLE ON)\n      elseif( \"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"Intel\" )\n        set(LLVM_COMPILER_IS_GCC_COMPATIBLE ON)\n      endif()\n    endif()\n    \n    \n    if(NOT DEFINED LLVM_STDLIB_HANDLED)\n      set(LLVM_STDLIB_HANDLED ON)\n    \n      function(append value)\n        foreach(variable ${ARGN})\n          set(${variable} \"${${variable}} ${value}\" PARENT_SCOPE)\n        endforeach(variable)\n      endfunction()\n    \n      include(CheckCXXCompilerFlag)\n      if(LLVM_ENABLE_LIBCXX)\n        if(LLVM_COMPILER_IS_GCC_COMPATIBLE)\n          check_cxx_compiler_flag(\"-stdlib=libc++\" CXX_SUPPORTS_STDLIB)\n          if(CXX_SUPPORTS_STDLIB)\n            append(\"-stdlib=libc++\"\n              CMAKE_CXX_FLAGS CMAKE_EXE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS\n              CMAKE_MODULE_LINKER_FLAGS)\n          else()\n            message(WARNING \"Can't specify libc++ with '-stdlib='\")\n          endif()\n        else()\n          message(WARNING \"Not sure how to specify libc++ for this compiler\")\n        endif()\n      endif()\n    endif()\n    \n    include(CheckCCompilerFlag)\n    include(CheckCXXCompilerFlag)\n    \n    if(CMAKE_LINKER MATCHES \"lld-link.exe\" OR (WIN32 AND LLVM_USE_LINKER STREQUAL \"lld\"))\n      set(LINKER_IS_LLD_LINK TRUE)\n    else()\n      set(LINKER_IS_LLD_LINK FALSE)\n    endif()\n    \n    set(LLVM_ENABLE_LTO OFF CACHE STRING \"Build LLVM with LTO. May be specified as Thin or Full to use a particular kind of LTO\")\n    string(TOUPPER \"${LLVM_ENABLE_LTO}\" uppercase_LLVM_ENABLE_LTO)\n    \n    # Ninja Job Pool support\n    # The following only works with the Ninja generator in CMake >= 3.0.\n    set(LLVM_PARALLEL_COMPILE_JOBS \"\" CACHE STRING\n      \"Define the maximum number of concurrent compilation jobs.\")\n    if(LLVM_PARALLEL_COMPILE_JOBS)\n      if(NOT CMAKE_MAKE_PROGRAM MATCHES \"ninja\")\n        message(WARNING \"Job pooling is only available with Ninja generators.\")\n      else()\n        set_property(GLOBAL APPEND PROPERTY JOB_POOLS compile_job_pool=${LLVM_PARALLEL_COMPILE_JOBS})\n        set(CMAKE_JOB_POOL_COMPILE compile_job_pool)\n      endif()\n    endif()\n    \n    set(LLVM_PARALLEL_LINK_JOBS \"\" CACHE STRING\n      \"Define the maximum number of concurrent link jobs.\")\n    if(CMAKE_MAKE_PROGRAM MATCHES \"ninja\")\n      if(NOT LLVM_PARALLEL_LINK_JOBS AND uppercase_LLVM_ENABLE_LTO STREQUAL \"THIN\")\n        message(STATUS \"ThinLTO provides its own parallel linking - limiting parallel link jobs to 2.\")\n        set(LLVM_PARALLEL_LINK_JOBS \"2\")\n      endif()\n      if(LLVM_PARALLEL_LINK_JOBS)\n        set_property(GLOBAL APPEND PROPERTY JOB_POOLS link_job_pool=${LLVM_PARALLEL_LINK_JOBS})\n        set(CMAKE_JOB_POOL_LINK link_job_pool)\n      endif()\n    elseif(LLVM_PARALLEL_LINK_JOBS)\n      message(WARNING \"Job pooling is only available with Ninja generators.\")\n    endif()\n    \n    if (LINKER_IS_LLD_LINK)\n      # Pass \/MANIFEST:NO so that CMake doesn't run mt.exe on our binaries.  Adding\n      # manifests with mt.exe breaks LLD's symbol tables and takes as much time as\n      # the link. See PR24476.\n      append(\"\/MANIFEST:NO\"\n        CMAKE_EXE_LINKER_FLAGS CMAKE_MODULE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)\n    endif()\n    \n    if( LLVM_ENABLE_ASSERTIONS )\n      # MSVC doesn't like _DEBUG on release builds. See PR 4379.\n      if( NOT MSVC )\n        add_definitions( -D_DEBUG )\n      endif()\n      # On non-Debug builds cmake automatically defines NDEBUG, so we\n      # explicitly undefine it:\n      if( NOT uppercase_CMAKE_BUILD_TYPE STREQUAL \"DEBUG\" )\n        add_definitions( -UNDEBUG )\n        # Also remove \/D NDEBUG to avoid MSVC warnings about conflicting defines.\n        foreach (flags_var_to_scrub\n            CMAKE_CXX_FLAGS_RELEASE\n            CMAKE_CXX_FLAGS_RELWITHDEBINFO\n            CMAKE_CXX_FLAGS_MINSIZEREL\n            CMAKE_C_FLAGS_RELEASE\n            CMAKE_C_FLAGS_RELWITHDEBINFO\n            CMAKE_C_FLAGS_MINSIZEREL)\n          string (REGEX REPLACE \"(^| )[\/-]D *NDEBUG($| )\" \" \"\n            \"${flags_var_to_scrub}\" \"${${flags_var_to_scrub}}\")\n        endforeach()\n      endif()\n    endif()\n    \n    if(LLVM_ENABLE_EXPENSIVE_CHECKS)\n      add_definitions(-DEXPENSIVE_CHECKS)\n      add_definitions(-D_GLIBCXX_DEBUG)\n    endif()\n    \n    string(TOUPPER \"${LLVM_ABI_BREAKING_CHECKS}\" uppercase_LLVM_ABI_BREAKING_CHECKS)\n    \n    if( uppercase_LLVM_ABI_BREAKING_CHECKS STREQUAL \"WITH_ASSERTS\" )\n      if( LLVM_ENABLE_ASSERTIONS )\n        set( LLVM_ENABLE_ABI_BREAKING_CHECKS 1 )\n      endif()\n    elseif( uppercase_LLVM_ABI_BREAKING_CHECKS STREQUAL \"FORCE_ON\" )\n      set( LLVM_ENABLE_ABI_BREAKING_CHECKS 1 )\n    elseif( uppercase_LLVM_ABI_BREAKING_CHECKS STREQUAL \"FORCE_OFF\" )\n      # We don't need to do anything special to turn off ABI breaking checks.\n    elseif( NOT DEFINED LLVM_ABI_BREAKING_CHECKS )\n      # Treat LLVM_ABI_BREAKING_CHECKS like \"FORCE_OFF\" when it has not been\n      # defined.\n    else()\n      message(FATAL_ERROR \"Unknown value for LLVM_ABI_BREAKING_CHECKS: \\\"${LLVM_ABI_BREAKING_CHECKS}\\\"!\")\n    endif()\n    \n    if(WIN32)\n      set(LLVM_HAVE_LINK_VERSION_SCRIPT 0)\n      if(CYGWIN)\n        set(LLVM_ON_WIN32 0)\n        set(LLVM_ON_UNIX 1)\n      else(CYGWIN)\n        set(LLVM_ON_WIN32 1)\n        set(LLVM_ON_UNIX 0)\n      endif(CYGWIN)\n    else(WIN32)\n      if(UNIX)\n        set(LLVM_ON_WIN32 0)\n        set(LLVM_ON_UNIX 1)\n        if(APPLE OR ${CMAKE_SYSTEM_NAME} MATCHES \"AIX\")\n          set(LLVM_HAVE_LINK_VERSION_SCRIPT 0)\n        else()\n          set(LLVM_HAVE_LINK_VERSION_SCRIPT 1)\n        endif()\n      else(UNIX)\n        MESSAGE(SEND_ERROR \"Unable to determine platform\")\n      endif(UNIX)\n    endif(WIN32)\n    \n    set(EXEEXT ${CMAKE_EXECUTABLE_SUFFIX})\n    set(LTDL_SHLIB_EXT ${CMAKE_SHARED_LIBRARY_SUFFIX})\n    \n    # We use *.dylib rather than *.so on darwin.\n    set(LLVM_PLUGIN_EXT ${CMAKE_SHARED_LIBRARY_SUFFIX})\n    \n    if(APPLE)\n      if(LLVM_ENABLE_LLD AND LLVM_ENABLE_LTO)\n        message(FATAL_ERROR \"lld does not support LTO on Darwin\")\n      endif()\n      # Darwin-specific linker flags for loadable modules.\n      set(CMAKE_MODULE_LINKER_FLAGS \"${CMAKE_MODULE_LINKER_FLAGS} -Wl,-flat_namespace -Wl,-undefined -Wl,suppress\")\n    endif()\n    \n    # Pass -Wl,-z,defs. This makes sure all symbols are defined. Otherwise a DSO\n    # build might work on ELF but fail on MachO\/COFF.\n    if(NOT (${CMAKE_SYSTEM_NAME} MATCHES \"Darwin\" OR WIN32 OR CYGWIN OR\n            ${CMAKE_SYSTEM_NAME} MATCHES \"FreeBSD\" OR\n            ${CMAKE_SYSTEM_NAME} MATCHES \"OpenBSD\") AND\n       NOT LLVM_USE_SANITIZER)\n      set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -Wl,-z,defs\")\n    endif()\n    \n    \n    function(append value)\n      foreach(variable ${ARGN})\n        set(${variable} \"${${variable}} ${value}\" PARENT_SCOPE)\n      endforeach(variable)\n    endfunction()\n    \n    function(append_if condition value)\n      if (${condition})\n        foreach(variable ${ARGN})\n          set(${variable} \"${${variable}} ${value}\" PARENT_SCOPE)\n        endforeach(variable)\n      endif()\n    endfunction()\n    \n    macro(add_flag_if_supported flag name)\n      check_c_compiler_flag(\"-Werror ${flag}\" \"C_SUPPORTS_${name}\")\n      append_if(\"C_SUPPORTS_${name}\" \"${flag}\" CMAKE_C_FLAGS)\n      check_cxx_compiler_flag(\"-Werror ${flag}\" \"CXX_SUPPORTS_${name}\")\n      append_if(\"CXX_SUPPORTS_${name}\" \"${flag}\" CMAKE_CXX_FLAGS)\n    endmacro()\n    \n    function(add_flag_or_print_warning flag name)\n      check_c_compiler_flag(\"-Werror ${flag}\" \"C_SUPPORTS_${name}\")\n      check_cxx_compiler_flag(\"-Werror ${flag}\" \"CXX_SUPPORTS_${name}\")\n      if (C_SUPPORTS_${name} AND CXX_SUPPORTS_${name})\n        message(STATUS \"Building with ${flag}\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${flag}\" PARENT_SCOPE)\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${flag}\" PARENT_SCOPE)\n        set(CMAKE_ASM_FLAGS \"${CMAKE_ASM_FLAGS} ${flag}\" PARENT_SCOPE)\n      else()\n        message(WARNING \"${flag} is not supported.\")\n      endif()\n    endfunction()\n    \n    if( LLVM_ENABLE_LLD )\n        if ( LLVM_USE_LINKER )\n            message(FATAL_ERROR \"LLVM_ENABLE_LLD and LLVM_USE_LINKER can't be set at the same time\")\n        endif()\n        set(LLVM_USE_LINKER \"lld\")\n    endif()\n    \n    if( LLVM_USE_LINKER )\n      check_cxx_compiler_flag(\"-fuse-ld=${LLVM_USE_LINKER}\" CXX_SUPPORTS_CUSTOM_LINKER)\n      if ( NOT CXX_SUPPORTS_CUSTOM_LINKER )\n          message(FATAL_ERROR \"Host compiler does not support '-fuse-ld=${LLVM_USE_LINKER}'\")\n      endif()\n      append(\"-fuse-ld=${LLVM_USE_LINKER}\"\n        CMAKE_EXE_LINKER_FLAGS CMAKE_MODULE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)\n    endif()\n    \n    if( LLVM_ENABLE_PIC )\n      if( XCODE )\n        # Xcode has -mdynamic-no-pic on by default, which overrides -fPIC. I don't\n        # know how to disable this, so just force ENABLE_PIC off for now.\n        message(WARNING \"-fPIC not supported with Xcode.\")\n      elseif( WIN32 OR CYGWIN)\n        # On Windows all code is PIC. MinGW warns if -fPIC is used.\n      else()\n        add_flag_or_print_warning(\"-fPIC\" FPIC)\n      endif()\n    endif()\n    \n    if(NOT WIN32 AND NOT CYGWIN)\n      # MinGW warns if -fvisibility-inlines-hidden is used.\n      check_cxx_compiler_flag(\"-fvisibility-inlines-hidden\" SUPPORTS_FVISIBILITY_INLINES_HIDDEN_FLAG)\n      append_if(SUPPORTS_FVISIBILITY_INLINES_HIDDEN_FLAG \"-fvisibility-inlines-hidden\" CMAKE_CXX_FLAGS)\n    endif()\n    \n    if( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT WIN32 )\n      # TODO: support other platforms and toolchains.\n      if( LLVM_BUILD_32_BITS )\n        message(STATUS \"Building 32 bits executables and libraries.\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -m32\")\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -m32\")\n        set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -m32\")\n        set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -m32\")\n        set(CMAKE_MODULE_LINKER_FLAGS \"${CMAKE_MODULE_LINKER_FLAGS} -m32\")\n      endif( LLVM_BUILD_32_BITS )\n    endif( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT WIN32 )\n    \n    # If building on a GNU specific 32-bit system, make sure off_t is 64 bits\n    # so that off_t can stored offset > 2GB\n    if( CMAKE_SIZEOF_VOID_P EQUAL 4 )\n      add_definitions( -D_LARGEFILE_SOURCE )\n      add_definitions( -D_FILE_OFFSET_BITS=64 )\n    endif()\n    \n    if( XCODE )\n      # For Xcode enable several build settings that correspond to\n      # many warnings that are on by default in Clang but are\n      # not enabled for historical reasons.  For versions of Xcode\n      # that do not support these options they will simply\n      # be ignored.\n      set(CMAKE_XCODE_ATTRIBUTE_GCC_WARN_ABOUT_RETURN_TYPE \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_GCC_WARN_ABOUT_MISSING_NEWLINE \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_GCC_WARN_UNUSED_VALUE \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_GCC_WARN_UNUSED_VARIABLE \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_GCC_WARN_SIGN_COMPARE \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_GCC_WARN_UNUSED_FUNCTION \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_GCC_WARN_INITIALIZER_NOT_FULLY_BRACKETED \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_GCC_WARN_HIDDEN_VIRTUAL_FUNCTIONS \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_GCC_WARN_UNINITIALIZED_AUTOS \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_CLANG_WARN_BOOL_CONVERSION \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_CLANG_WARN_EMPTY_BODY \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_CLANG_WARN_ENUM_CONVERSION \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_CLANG_WARN_INT_CONVERSION \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_CLANG_WARN_CONSTANT_CONVERSION \"YES\")\n      set(CMAKE_XCODE_ATTRIBUTE_GCC_WARN_NON_VIRTUAL_DESTRUCTOR \"YES\")\n    endif()\n    \n    # On Win32 using MS tools, provide an option to set the number of parallel jobs\n    # to use.\n    if( MSVC_IDE )\n      set(LLVM_COMPILER_JOBS \"0\" CACHE STRING\n        \"Number of parallel compiler jobs. 0 means use all processors. Default is 0.\")\n      if( NOT LLVM_COMPILER_JOBS STREQUAL \"1\" )\n        if( LLVM_COMPILER_JOBS STREQUAL \"0\" )\n          add_definitions( \/MP )\n        else()\n          message(STATUS \"Number of parallel compiler jobs set to \" ${LLVM_COMPILER_JOBS})\n          add_definitions( \/MP${LLVM_COMPILER_JOBS} )\n        endif()\n      else()\n        message(STATUS \"Parallel compilation disabled\")\n      endif()\n    endif()\n    \n    # set stack reserved size to ~10MB\n    if(MSVC)\n      # CMake previously automatically set this value for MSVC builds, but the\n      # behavior was changed in CMake 2.8.11 (Issue 12437) to use the MSVC default\n      # value (1 MB) which is not enough for us in tasks such as parsing recursive\n      # C++ templates in Clang.\n      set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} \/STACK:10000000\")\n    elseif(MINGW) # FIXME: Also cygwin?\n      set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -Wl,--stack,16777216\")\n    \n      # Pass -mbig-obj to mingw gas on Win64. COFF has a 2**16 section limit, and\n      # on Win64, every COMDAT function creates at least 3 sections: .text, .pdata,\n      # and .xdata.\n      if (CMAKE_SIZEOF_VOID_P EQUAL 8)\n        append(\"-Wa,-mbig-obj\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n      endif()\n    endif()\n    \n    if( MSVC )\n      if( CMAKE_CXX_COMPILER_VERSION VERSION_LESS 19.0 )\n        # For MSVC 2013, disable iterator null pointer checking in debug mode,\n        # especially so std::equal(nullptr, nullptr, nullptr) will not assert.\n        add_definitions(\"-D_DEBUG_POINTER_IMPL=\")\n      endif()\n    \n    # The macro choose_msvc_crt() takes a list of possible\n    # C runtimes to choose from, in the form of compiler flags,\n    # to present to the user. (MTd for \/MTd, etc)\n    #\n    # The macro is invoked at the end of the file.\n    #\n    # CMake already sets CRT flags in the CMAKE_CXX_FLAGS_* and\n    # CMAKE_C_FLAGS_* variables by default. To let the user\n    # override that for each build type:\n    # 1. Detect which CRT is already selected, and reflect this in\n    # LLVM_USE_CRT_* so the user can have a better idea of what\n    # changes they're making.\n    # 2. Replace the flags in both variables with the new flag via a regex.\n    # 3. set() the variables back into the cache so the changes\n    # are user-visible.\n    \n    ### Helper macros: ###\n    macro(make_crt_regex regex crts)\n      set(${regex} \"\")\n      foreach(crt ${${crts}})\n        # Trying to match the beginning or end of the string with stuff\n        # like [ ^]+ didn't work, so use a bunch of parentheses instead.\n        set(${regex} \"${${regex}}|(^| +)\/${crt}($| +)\")\n      endforeach(crt)\n      string(REGEX REPLACE \"^\\\\|\" \"\" ${regex} \"${${regex}}\")\n    endmacro(make_crt_regex)\n    \n    macro(get_current_crt crt_current regex flagsvar)\n      # Find the selected-by-CMake CRT for each build type, if any.\n      # Strip off the leading slash and any whitespace.\n      string(REGEX MATCH \"${${regex}}\" ${crt_current} \"${${flagsvar}}\")\n      string(REPLACE \"\/\" \" \" ${crt_current} \"${${crt_current}}\")\n      string(STRIP \"${${crt_current}}\" ${crt_current})\n    endmacro(get_current_crt)\n    \n    # Replaces or adds a flag to a variable.\n    # Expects 'flag' to be padded with spaces.\n    macro(set_flag_in_var flagsvar regex flag)\n      string(REGEX MATCH \"${${regex}}\" current_flag \"${${flagsvar}}\")\n      if(\"${current_flag}\" STREQUAL \"\")\n        set(${flagsvar} \"${${flagsvar}}${${flag}}\")\n      else()\n        string(REGEX REPLACE \"${${regex}}\" \"${${flag}}\" ${flagsvar} \"${${flagsvar}}\")\n      endif()\n      string(STRIP \"${${flagsvar}}\" ${flagsvar})\n      # Make sure this change gets reflected in the cache\/gui.\n      # CMake requires the docstring parameter whenever set() touches the cache,\n      # so get the existing docstring and re-use that.\n      get_property(flagsvar_docs CACHE ${flagsvar} PROPERTY HELPSTRING)\n      set(${flagsvar} \"${${flagsvar}}\" CACHE STRING \"${flagsvar_docs}\" FORCE)\n    endmacro(set_flag_in_var)\n    \n      if( MSVC11 )\n        add_definitions(-D_VARIADIC_MAX=10)\n      endif()\n    \n      # Add definitions that make MSVC much less annoying.\n      add_definitions(\n        # For some reason MS wants to deprecate a bunch of standard functions...\n        -D_CRT_SECURE_NO_DEPRECATE\n        -D_CRT_SECURE_NO_WARNINGS\n        -D_CRT_NONSTDC_NO_DEPRECATE\n        -D_CRT_NONSTDC_NO_WARNINGS\n        -D_SCL_SECURE_NO_DEPRECATE\n        -D_SCL_SECURE_NO_WARNINGS\n        )\n    \n      # Tell MSVC to use the Unicode version of the Win32 APIs instead of ANSI.\n      add_definitions(\n        -DUNICODE\n        -D_UNICODE\n      )\n    \n      if (LLVM_ENABLE_WERROR)\n        append(\"\/WX\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n      endif (LLVM_ENABLE_WERROR)\n    \n      append(\"\/Zc:inline\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n    \n      # \/Zc:strictStrings is incompatible with VS12's (Visual Studio 2013's)\n      # debug mode headers. Instead of only enabling them in VS2013's debug mode,\n      # we'll just enable them for Visual Studio 2015 (VS 14, MSVC_VERSION 1900)\n      # and up.\n      if (NOT (MSVC_VERSION LESS 1900))\n        # Disable string literal const->non-const type conversion.\n        # \"When specified, the compiler requires strict const-qualification\n        # conformance for pointers initialized by using string literals.\"\n        append(\"\/Zc:strictStrings\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n      endif(NOT (MSVC_VERSION LESS 1900))\n    \n      # \"Generate Intrinsic Functions\".\n      append(\"\/Oi\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n    \n      # \"Enforce type conversion rules\".\n      append(\"\/Zc:rvalueCast\" CMAKE_CXX_FLAGS)\n    \n      if (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" AND NOT LLVM_ENABLE_LTO)\n        # clang-cl and cl by default produce non-deterministic binaries because\n        # link.exe \/incremental requires a timestamp in the .obj file.  clang-cl\n        # has the flag \/Brepro to force deterministic binaries. We want to pass that\n        # whenever you're building with clang unless you're passing \/incremental\n        # or using LTO (\/Brepro with LTO would result in a warning about the flag\n        # being unused, because we're not generating object files).\n        # This checks CMAKE_CXX_COMPILER_ID in addition to check_cxx_compiler_flag()\n        # because cl.exe does not emit an error on flags it doesn't understand,\n        # letting check_cxx_compiler_flag() claim it understands all flags.\n        check_cxx_compiler_flag(\"\/Brepro\" SUPPORTS_BREPRO)\n        if (SUPPORTS_BREPRO)\n          # Check if \/INCREMENTAL is passed to the linker and complain that it\n          # won't work with \/Brepro.\n          string(TOUPPER \"${CMAKE_EXE_LINKER_FLAGS}\" upper_exe_flags)\n          string(TOUPPER \"${CMAKE_MODULE_LINKER_FLAGS}\" upper_module_flags)\n          string(TOUPPER \"${CMAKE_SHARED_LINKER_FLAGS}\" upper_shared_flags)\n    \n          string(FIND \"${upper_exe_flags} ${upper_module_flags} ${upper_shared_flags}\"\n            \"\/INCREMENTAL\" linker_flag_idx)\n    \n          if (${linker_flag_idx} GREATER -1)\n            message(WARNING \"\/Brepro not compatible with \/INCREMENTAL linking - builds will be non-deterministic\")\n          else()\n            append(\"\/Brepro\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n          endif()\n        endif()\n      endif()\n    \n    elseif( LLVM_COMPILER_IS_GCC_COMPATIBLE )\n      append_if(LLVM_ENABLE_WERROR \"-Werror\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n      add_flag_if_supported(\"-Werror=date-time\" WERROR_DATE_TIME)\n      if (LLVM_ENABLE_CXX1Y)\n        check_cxx_compiler_flag(\"-std=c++1y\" CXX_SUPPORTS_CXX1Y)\n        append_if(CXX_SUPPORTS_CXX1Y \"-std=c++1y\" CMAKE_CXX_FLAGS)\n      else()\n        check_cxx_compiler_flag(\"-std=c++11\" CXX_SUPPORTS_CXX11)\n        if (CXX_SUPPORTS_CXX11)\n          if (CYGWIN OR MINGW)\n            # MinGW and Cygwin are a bit stricter and lack things like\n            # 'strdup', 'stricmp', etc in c++11 mode.\n            append(\"-std=gnu++11\" CMAKE_CXX_FLAGS)\n          else()\n            append(\"-std=c++11\" CMAKE_CXX_FLAGS)\n          endif()\n        else()\n          message(FATAL_ERROR \"LLVM requires C++11 support but the '-std=c++11' flag isn't supported.\")\n        endif()\n      endif()\n      if (LLVM_ENABLE_MODULES)\n        set(OLD_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})\n        set(module_flags \"-fmodules -fmodules-cache-path=${PROJECT_BINARY_DIR}\/module.cache\")\n        if (${CMAKE_SYSTEM_NAME} MATCHES \"Darwin\")\n          # On Darwin -fmodules does not imply -fcxx-modules.\n          set(module_flags \"${module_flags} -fcxx-modules\")\n        endif()\n        if (LLVM_ENABLE_LOCAL_SUBMODULE_VISIBILITY)\n          set(module_flags \"${module_flags} -Xclang -fmodules-local-submodule-visibility\")\n        endif()\n        if (LLVM_ENABLE_MODULE_DEBUGGING AND\n            ((uppercase_CMAKE_BUILD_TYPE STREQUAL \"DEBUG\") OR\n             (uppercase_CMAKE_BUILD_TYPE STREQUAL \"RELWITHDEBINFO\")))\n          set(module_flags \"${module_flags} -gmodules\")\n        endif()\n        set(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} ${module_flags}\")\n    \n        # Check that we can build code with modules enabled, and that repeatedly\n        # including <cassert> still manages to respect NDEBUG properly.\n        CHECK_CXX_SOURCE_COMPILES(\"#undef NDEBUG\n                                   #include <cassert>\n                                   #define NDEBUG\n                                   #include <cassert>\n                                   int main() { assert(this code is not compiled); }\"\n                                   CXX_SUPPORTS_MODULES)\n        set(CMAKE_REQUIRED_FLAGS ${OLD_CMAKE_REQUIRED_FLAGS})\n        if (CXX_SUPPORTS_MODULES)\n          append(\"${module_flags}\" CMAKE_CXX_FLAGS)\n        else()\n          message(FATAL_ERROR \"LLVM_ENABLE_MODULES is not supported by this compiler\")\n        endif()\n      endif(LLVM_ENABLE_MODULES)\n    endif( MSVC )\n    \n    if (MSVC AND NOT CLANG_CL)\n      set(msvc_warning_flags\n        # Disabled warnings.\n        -wd4141 # Suppress ''modifier' : used more than once' (because of __forceinline combined with inline)\n        -wd4146 # Suppress 'unary minus operator applied to unsigned type, result still unsigned'\n        -wd4180 # Suppress 'qualifier applied to function type has no meaning; ignored'\n        -wd4244 # Suppress ''argument' : conversion from 'type1' to 'type2', possible loss of data'\n        -wd4258 # Suppress ''var' : definition from the for loop is ignored; the definition from the enclosing scope is used'\n        -wd4267 # Suppress ''var' : conversion from 'size_t' to 'type', possible loss of data'\n        -wd4291 # Suppress ''declaration' : no matching operator delete found; memory will not be freed if initialization throws an exception'\n        -wd4345 # Suppress 'behavior change: an object of POD type constructed with an initializer of the form () will be default-initialized'\n        -wd4351 # Suppress 'new behavior: elements of array 'array' will be default initialized'\n        -wd4355 # Suppress ''this' : used in base member initializer list'\n        -wd4456 # Suppress 'declaration of 'var' hides local variable'\n        -wd4457 # Suppress 'declaration of 'var' hides function parameter'\n        -wd4458 # Suppress 'declaration of 'var' hides class member'\n        -wd4459 # Suppress 'declaration of 'var' hides global declaration'\n        -wd4503 # Suppress ''identifier' : decorated name length exceeded, name was truncated'\n        -wd4624 # Suppress ''derived class' : destructor could not be generated because a base class destructor is inaccessible'\n        -wd4722 # Suppress 'function' : destructor never returns, potential memory leak\n        -wd4800 # Suppress ''type' : forcing value to bool 'true' or 'false' (performance warning)'\n        -wd4100 # Suppress 'unreferenced formal parameter'\n        -wd4127 # Suppress 'conditional expression is constant'\n        -wd4512 # Suppress 'assignment operator could not be generated'\n        -wd4505 # Suppress 'unreferenced local function has been removed'\n        -wd4610 # Suppress '<class> can never be instantiated'\n        -wd4510 # Suppress 'default constructor could not be generated'\n        -wd4702 # Suppress 'unreachable code'\n        -wd4245 # Suppress 'signed\/unsigned mismatch'\n        -wd4706 # Suppress 'assignment within conditional expression'\n        -wd4310 # Suppress 'cast truncates constant value'\n        -wd4701 # Suppress 'potentially uninitialized local variable'\n        -wd4703 # Suppress 'potentially uninitialized local pointer variable'\n        -wd4389 # Suppress 'signed\/unsigned mismatch'\n        -wd4611 # Suppress 'interaction between '_setjmp' and C++ object destruction is non-portable'\n        -wd4805 # Suppress 'unsafe mix of type <type> and type <type> in operation'\n        -wd4204 # Suppress 'nonstandard extension used : non-constant aggregate initializer'\n        -wd4577 # Suppress 'noexcept used with no exception handling mode specified; termination on exception is not guaranteed'\n        -wd4091 # Suppress 'typedef: ignored on left of '' when no variable is declared'\n            # C4592 is disabled because of false positives in Visual Studio 2015\n            # Update 1. Re-evaluate the usefulness of this diagnostic with Update 2.\n        -wd4592 # Suppress ''var': symbol will be dynamically initialized (implementation limitation)\n        -wd4319 # Suppress ''operator' : zero extending 'type' to 'type' of greater size'\n    \n        # Ideally, we'd like this warning to be enabled, but MSVC 2013 doesn't\n        # support the 'aligned' attribute in the way that clang sources requires (for\n        # any code that uses the LLVM_ALIGNAS macro), so this is must be disabled to\n        # avoid unwanted alignment warnings.\n        # When we switch to requiring a version of MSVC that supports the 'alignas'\n        # specifier (MSVC 2015?) this warning can be re-enabled.\n        -wd4324 # Suppress 'structure was padded due to __declspec(align())'\n    \n        # Promoted warnings.\n        -w14062 # Promote 'enumerator in switch of enum is not handled' to level 1 warning.\n    \n        # Promoted warnings to errors.\n        -we4238 # Promote 'nonstandard extension used : class rvalue used as lvalue' to error.\n        )\n    \n      # Enable warnings\n      if (LLVM_ENABLE_WARNINGS)\n        # Put \/W4 in front of all the -we flags. cl.exe doesn't care, but for\n        # clang-cl having \/W4 after the -we flags will re-enable the warnings\n        # disabled by -we.\n        set(msvc_warning_flags \"\/W4 ${msvc_warning_flags}\")\n        # CMake appends \/W3 by default, and having \/W3 followed by \/W4 will result in\n        # cl : Command line warning D9025 : overriding '\/W3' with '\/W4'.  Since this is\n        # a command line warning and not a compiler warning, it cannot be suppressed except\n        # by fixing the command line.\n        string(REGEX REPLACE \" \/W[0-4]\" \"\" CMAKE_C_FLAGS \"${CMAKE_C_FLAGS}\")\n        string(REGEX REPLACE \" \/W[0-4]\" \"\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n    \n        if (LLVM_ENABLE_PEDANTIC)\n          # No MSVC equivalent available\n        endif (LLVM_ENABLE_PEDANTIC)\n      endif (LLVM_ENABLE_WARNINGS)\n    \n      foreach(flag ${msvc_warning_flags})\n        append(\"${flag}\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n      endforeach(flag)\n    endif (MSVC AND NOT CLANG_CL)\n    \n    if (LLVM_ENABLE_WARNINGS AND (LLVM_COMPILER_IS_GCC_COMPATIBLE OR CLANG_CL))\n      append(\"-Wall -W -Wno-unused-parameter -Wwrite-strings\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n      append(\"-Wcast-qual\" CMAKE_CXX_FLAGS)\n    \n      # Turn off missing field initializer warnings for gcc to avoid noise from\n      # false positives with empty {}. Turn them on otherwise (they're off by\n      # default for clang).\n      check_cxx_compiler_flag(\"-Wmissing-field-initializers\" CXX_SUPPORTS_MISSING_FIELD_INITIALIZERS_FLAG)\n      if (CXX_SUPPORTS_MISSING_FIELD_INITIALIZERS_FLAG)\n        if (CMAKE_COMPILER_IS_GNUCXX)\n          append(\"-Wno-missing-field-initializers\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n        else()\n          append(\"-Wmissing-field-initializers\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n        endif()\n      endif()\n    \n      if (LLVM_ENABLE_PEDANTIC AND LLVM_COMPILER_IS_GCC_COMPATIBLE)\n        append(\"-pedantic\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n        append(\"-Wno-long-long\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n      endif()\n    \n      add_flag_if_supported(\"-Wcovered-switch-default\" COVERED_SWITCH_DEFAULT_FLAG)\n      append_if(USE_NO_UNINITIALIZED \"-Wno-uninitialized\" CMAKE_CXX_FLAGS)\n      append_if(USE_NO_MAYBE_UNINITIALIZED \"-Wno-maybe-uninitialized\" CMAKE_CXX_FLAGS)\n    \n      # Check if -Wnon-virtual-dtor warns even though the class is marked final.\n      # If it does, don't add it. So it won't be added on clang 3.4 and older.\n      # This also catches cases when -Wnon-virtual-dtor isn't supported by\n      # the compiler at all.  This flag is not activated for gcc since it will\n      # incorrectly identify a protected non-virtual base when there is a friend\n      # declaration. Don't activate this in general on Windows as this warning has\n      # too many false positives on COM-style classes, which are destroyed with\n      # Release() (PR32286).\n      if (NOT CMAKE_COMPILER_IS_GNUCXX AND NOT WIN32)\n        set(OLD_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})\n        set(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} -std=c++11 -Werror=non-virtual-dtor\")\n        CHECK_CXX_SOURCE_COMPILES(\"class base {public: virtual void anchor();protected: ~base();};\n                                   class derived final : public base { public: ~derived();};\n                                   int main() { return 0; }\"\n                                  CXX_WONT_WARN_ON_FINAL_NONVIRTUALDTOR)\n        set(CMAKE_REQUIRED_FLAGS ${OLD_CMAKE_REQUIRED_FLAGS})\n        append_if(CXX_WONT_WARN_ON_FINAL_NONVIRTUALDTOR\n                  \"-Wnon-virtual-dtor\" CMAKE_CXX_FLAGS)\n      endif()\n    \n      # Enable -Wdelete-non-virtual-dtor if available.\n      add_flag_if_supported(\"-Wdelete-non-virtual-dtor\" DELETE_NON_VIRTUAL_DTOR_FLAG)\n    \n      # Check if -Wcomment is OK with an \/\/ comment ending with '\\' if the next\n      # line is also a \/\/ comment.\n      set(OLD_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})\n      set(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} -Werror -Wcomment\")\n      CHECK_C_SOURCE_COMPILES(\"\/\/ \\\\\\\\\\\\n\/\/\\\\nint main() {return 0;}\"\n                              C_WCOMMENT_ALLOWS_LINE_WRAP)\n      set(CMAKE_REQUIRED_FLAGS ${OLD_CMAKE_REQUIRED_FLAGS})\n      if (NOT C_WCOMMENT_ALLOWS_LINE_WRAP)\n        append(\"-Wno-comment\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n      endif()\n    \n      # Enable -Wstring-conversion to catch misuse of string literals.\n      add_flag_if_supported(\"-Wstring-conversion\" STRING_CONVERSION_FLAG)\n    endif (LLVM_ENABLE_WARNINGS AND (LLVM_COMPILER_IS_GCC_COMPATIBLE OR CLANG_CL))\n    \n    if (LLVM_COMPILER_IS_GCC_COMPATIBLE AND NOT LLVM_ENABLE_WARNINGS)\n      append(\"-w\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n    endif()\n    \n    \n    \n    macro(append_common_sanitizer_flags)\n      if (NOT MSVC)\n        # Append -fno-omit-frame-pointer and turn on debug info to get better\n        # stack traces.\n        add_flag_if_supported(\"-fno-omit-frame-pointer\" FNO_OMIT_FRAME_POINTER)\n        if (NOT uppercase_CMAKE_BUILD_TYPE STREQUAL \"DEBUG\" AND\n            NOT uppercase_CMAKE_BUILD_TYPE STREQUAL \"RELWITHDEBINFO\")\n          add_flag_if_supported(\"-gline-tables-only\" GLINE_TABLES_ONLY)\n        endif()\n        # Use -O1 even in debug mode, otherwise sanitizers slowdown is too large.\n        if (uppercase_CMAKE_BUILD_TYPE STREQUAL \"DEBUG\")\n          add_flag_if_supported(\"-O1\" O1)\n        endif()\n      elseif (CLANG_CL)\n        # Keep frame pointers around.\n        append(\"\/Oy-\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n        if (LINKER_IS_LLD_LINK)\n          # Use DWARF debug info with LLD.\n          append(\"-gdwarf\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n        else()\n          # Enable codeview otherwise.\n          append(\"\/Z7\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n        endif()\n        # Always ask the linker to produce symbols with asan.\n        append(\"-debug\" CMAKE_EXE_LINKER_FLAGS CMAKE_MODULE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)\n      endif()\n    endmacro()\n    \n    # Turn on sanitizers if necessary.\n    if(LLVM_USE_SANITIZER)\n      if (LLVM_ON_UNIX)\n        if (LLVM_USE_SANITIZER STREQUAL \"Address\")\n          append_common_sanitizer_flags()\n          append(\"-fsanitize=address\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n        elseif (LLVM_USE_SANITIZER MATCHES \"Memory(WithOrigins)?\")\n          append_common_sanitizer_flags()\n          append(\"-fsanitize=memory\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n          if(LLVM_USE_SANITIZER STREQUAL \"MemoryWithOrigins\")\n            append(\"-fsanitize-memory-track-origins\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n          endif()\n        elseif (LLVM_USE_SANITIZER STREQUAL \"Undefined\")\n          append_common_sanitizer_flags()\n          append(\"-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all\"\n                  CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n          set(BLACKLIST_FILE \"${CMAKE_SOURCE_DIR}\/utils\/sanitizers\/ubsan_blacklist.txt\")\n          if (EXISTS \"${BLACKLIST_FILE}\")\n            append(\"-fsanitize-blacklist=${BLACKLIST_FILE}\"\n                      CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n          endif()\n        elseif (LLVM_USE_SANITIZER STREQUAL \"Thread\")\n          append_common_sanitizer_flags()\n          append(\"-fsanitize=thread\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n        elseif (LLVM_USE_SANITIZER STREQUAL \"Address;Undefined\" OR\n                LLVM_USE_SANITIZER STREQUAL \"Undefined;Address\")\n          append_common_sanitizer_flags()\n          append(\"-fsanitize=address,undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all\"\n                  CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n        else()\n          message(FATAL_ERROR \"Unsupported value of LLVM_USE_SANITIZER: ${LLVM_USE_SANITIZER}\")\n        endif()\n      elseif(MSVC)\n        if (LLVM_USE_SANITIZER STREQUAL \"Address\")\n          append_common_sanitizer_flags()\n          append(\"-fsanitize=address\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n        else()\n          message(FATAL_ERROR \"This sanitizer not yet supported in the MSVC environment: ${LLVM_USE_SANITIZER}\")\n        endif()\n      else()\n        message(FATAL_ERROR \"LLVM_USE_SANITIZER is not supported on this platform.\")\n      endif()\n      if (LLVM_USE_SANITIZER MATCHES \"(Undefined;)?Address(;Undefined)?\")\n        add_flag_if_supported(\"-fsanitize-address-use-after-scope\"\n                              FSANITIZE_USE_AFTER_SCOPE_FLAG)\n      endif()\n      if (LLVM_USE_SANITIZE_COVERAGE)\n        append(\"-fsanitize-coverage=trace-pc-guard,indirect-calls,trace-cmp\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n      endif()\n    endif()\n    \n    # Turn on -gsplit-dwarf if requested\n    if(LLVM_USE_SPLIT_DWARF)\n      add_definitions(\"-gsplit-dwarf\")\n    endif()\n    \n    add_definitions( -D__STDC_CONSTANT_MACROS )\n    add_definitions( -D__STDC_FORMAT_MACROS )\n    add_definitions( -D__STDC_LIMIT_MACROS )\n    \n    # clang doesn't print colored diagnostics when invoked from Ninja\n    if (UNIX AND\n        CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" AND\n        CMAKE_GENERATOR STREQUAL \"Ninja\")\n      append(\"-fcolor-diagnostics\" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)\n    endif()\n    \n    # lld doesn't print colored diagnostics when invoked from Ninja\n    if (UNIX AND CMAKE_GENERATOR STREQUAL \"Ninja\")\n      include(CheckLinkerFlag)\n      check_linker_flag(\"-Wl,-color-diagnostics\" LINKER_SUPPORTS_COLOR_DIAGNOSTICS)\n      append_if(LINKER_SUPPORTS_COLOR_DIAGNOSTICS \"-Wl,-color-diagnostics\"\n        CMAKE_EXE_LINKER_FLAGS CMAKE_MODULE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)\n    endif()\n    \n    # Add flags for add_dead_strip().\n    # FIXME: With MSVS, consider compiling with \/Gy and linking with \/OPT:REF?\n    # But MinSizeRel seems to add that automatically, so maybe disable these\n    # flags instead if LLVM_NO_DEAD_STRIP is set.\n    if(NOT CYGWIN AND NOT WIN32)\n      if(NOT ${CMAKE_SYSTEM_NAME} MATCHES \"Darwin\" AND\n         NOT uppercase_CMAKE_BUILD_TYPE STREQUAL \"DEBUG\")\n        check_c_compiler_flag(\"-Werror -fno-function-sections\" C_SUPPORTS_FNO_FUNCTION_SECTIONS)\n        if (C_SUPPORTS_FNO_FUNCTION_SECTIONS)\n          # Don't add -ffunction-section if it can be disabled with -fno-function-sections.\n          # Doing so will break sanitizers.\n          add_flag_if_supported(\"-ffunction-sections\" FFUNCTION_SECTIONS)\n        endif()\n        add_flag_if_supported(\"-fdata-sections\" FDATA_SECTIONS)\n      endif()\n    endif()\n    \n    \n    # Provide public options to globally control RTTI and EH\n    option(LLVM_ENABLE_EH \"Enable Exception handling\" OFF)\n    option(LLVM_ENABLE_RTTI \"Enable run time type information\" OFF)\n    if(LLVM_ENABLE_EH AND NOT LLVM_ENABLE_RTTI)\n      message(FATAL_ERROR \"Exception handling requires RTTI. You must set LLVM_ENABLE_RTTI to ON\")\n    endif()\n    \n    option(LLVM_BUILD_INSTRUMENTED \"Build LLVM and tools with PGO instrumentation (experimental)\" Off)\n    mark_as_advanced(LLVM_BUILD_INSTRUMENTED)\n    append_if(LLVM_BUILD_INSTRUMENTED \"-fprofile-instr-generate='${LLVM_PROFILE_FILE_PATTERN}'\"\n      CMAKE_CXX_FLAGS\n      CMAKE_C_FLAGS\n      CMAKE_EXE_LINKER_FLAGS\n      CMAKE_SHARED_LINKER_FLAGS)\n    \n    option(LLVM_BUILD_INSTRUMENTED_COVERAGE \"Build LLVM and tools with Code Coverage instrumentation (experimental)\" Off)\n    mark_as_advanced(LLVM_BUILD_INSTRUMENTED_COVERAGE)\n    append_if(LLVM_BUILD_INSTRUMENTED_COVERAGE \"-fprofile-instr-generate='${LLVM_PROFILE_FILE_PATTERN}' -fcoverage-mapping\"\n      CMAKE_CXX_FLAGS\n      CMAKE_C_FLAGS\n      CMAKE_EXE_LINKER_FLAGS\n      CMAKE_SHARED_LINKER_FLAGS)\n    \n    if(LLVM_ENABLE_LTO AND LLVM_ON_WIN32 AND NOT LINKER_IS_LLD_LINK)\n      message(FATAL_ERROR \"When compiling for Windows, LLVM_ENABLE_LTO requires using lld as the linker (point CMAKE_LINKER at lld-link.exe)\")\n    endif()\n    if(uppercase_LLVM_ENABLE_LTO STREQUAL \"THIN\")\n      append(\"-flto=thin\" CMAKE_CXX_FLAGS CMAKE_C_FLAGS)\n      if(NOT LINKER_IS_LLD_LINK)\n        append(\"-flto=thin\" CMAKE_EXE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)\n      endif()\n      # If the linker supports it, enable the lto cache. This improves initial build\n      # time a little since we re-link a lot of the same objects, and significantly\n      # improves incremental build time.\n      # FIXME: We should move all this logic into the clang driver.\n      if(APPLE)\n        append(\"-Wl,-cache_path_lto,${PROJECT_BINARY_DIR}\/lto.cache\"\n               CMAKE_EXE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)\n      elseif(UNIX AND LLVM_USE_LINKER STREQUAL \"lld\")\n        append(\"-Wl,--thinlto-cache-dir=${PROJECT_BINARY_DIR}\/lto.cache\"\n               CMAKE_EXE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)\n      elseif(LLVM_USE_LINKER STREQUAL \"gold\")\n        append(\"-Wl,--plugin-opt,cache-dir=${PROJECT_BINARY_DIR}\/lto.cache\"\n               CMAKE_EXE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)\n      endif()\n    elseif(uppercase_LLVM_ENABLE_LTO STREQUAL \"FULL\")\n      append(\"-flto=full\" CMAKE_CXX_FLAGS CMAKE_C_FLAGS)\n      if(NOT LINKER_IS_LLD_LINK)\n        append(\"-flto=full\" CMAKE_EXE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)\n      endif()\n    elseif(LLVM_ENABLE_LTO)\n      append(\"-flto\" CMAKE_CXX_FLAGS CMAKE_C_FLAGS)\n      if(NOT LINKER_IS_LLD_LINK)\n        append(\"-flto\" CMAKE_EXE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)\n      endif()\n    endif()\n    \n    # This option makes utils\/extract_symbols.py be used to determine the list of\n    # symbols to export from LLVM tools. This is necessary when using MSVC if you\n    # want to allow plugins, though note that the plugin has to explicitly link\n    # against (exactly one) tool so we can't unilaterally turn on\n    # LLVM_ENABLE_PLUGINS when it's enabled.\n    option(LLVM_EXPORT_SYMBOLS_FOR_PLUGINS \"Export symbols from LLVM tools so that plugins can import them\" OFF)\n    if(BUILD_SHARED_LIBS AND LLVM_EXPORT_SYMBOLS_FOR_PLUGINS)\n      message(FATAL_ERROR \"BUILD_SHARED_LIBS not compatible with LLVM_EXPORT_SYMBOLS_FOR_PLUGINS\")\n    endif()\n    if(LLVM_LINK_LLVM_DYLIB AND LLVM_EXPORT_SYMBOLS_FOR_PLUGINS)\n      message(FATAL_ERROR \"LLVM_LINK_LLVM_DYLIB not compatible with LLVM_EXPORT_SYMBOLS_FOR_PLUGINS\")\n    endif()\n    \n    # Plugin support\n    # FIXME: Make this configurable.\n    if(WIN32 OR CYGWIN)\n      if(BUILD_SHARED_LIBS)\n        set(LLVM_ENABLE_PLUGINS ON)\n      else()\n        set(LLVM_ENABLE_PLUGINS OFF)\n      endif()\n    else()\n      set(LLVM_ENABLE_PLUGINS ON)\n    endif()\n    \n    function(get_compile_definitions)\n      get_directory_property(top_dir_definitions DIRECTORY ${CMAKE_SOURCE_DIR} COMPILE_DEFINITIONS)\n      foreach(definition ${top_dir_definitions})\n        if(DEFINED result)\n          string(APPEND result \" -D${definition}\")\n        else()\n          set(result \"-D${definition}\")\n        endif()\n      endforeach()\n      set(LLVM_DEFINITIONS \"${result}\" PARENT_SCOPE)\n    endfunction()\n    get_compile_definitions()\n    \n    \n    # Configure all of the various header file fragments LLVM uses which depend on\n    # configuration variables.\n    set(LLVM_ENUM_TARGETS \"\")\n    set(LLVM_ENUM_ASM_PRINTERS \"\")\n    set(LLVM_ENUM_ASM_PARSERS \"\")\n    set(LLVM_ENUM_DISASSEMBLERS \"\")\n    foreach(t ${LLVM_TARGETS_TO_BUILD})\n      set( td ${SDIR}\/lib\/Target\/${t} )\n    \n      list(FIND LLVM_ALL_TARGETS ${t} idx)\n      list(FIND LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ${t} idy)\n      if( idx LESS 0 AND idy LESS 0 )\n        message(FATAL_ERROR \"The target `${t}' does not exist.\n        It should be one of\\n${LLVM_ALL_TARGETS}\")\n      else()\n        set(LLVM_ENUM_TARGETS \"${LLVM_ENUM_TARGETS}LLVM_TARGET(${t})\\n\")\n      endif()\n    \n      file(GLOB asmp_file \"${td}\/*AsmPrinter.cpp\")\n      if( asmp_file )\n        set(LLVM_ENUM_ASM_PRINTERS\n          \"${LLVM_ENUM_ASM_PRINTERS}LLVM_ASM_PRINTER(${t})\\n\")\n      endif()\n      if( EXISTS ${td}\/AsmParser\/CMakeLists.txt )\n        set(LLVM_ENUM_ASM_PARSERS\n          \"${LLVM_ENUM_ASM_PARSERS}LLVM_ASM_PARSER(${t})\\n\")\n      endif()\n      if( EXISTS ${td}\/Disassembler\/CMakeLists.txt )\n        set(LLVM_ENUM_DISASSEMBLERS\n          \"${LLVM_ENUM_DISASSEMBLERS}LLVM_DISASSEMBLER(${t})\\n\")\n      endif()\n    endforeach(t)\n    \n    \n    \n    \n    \n    set(LLVM_RPM_SPEC_REVISION \"0\")\n    \n    if(APPLE AND DARWIN_LTO_LIBRARY)\n      set(CMAKE_EXE_LINKER_FLAGS\n        \"${CMAKE_EXE_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}\")\n      set(CMAKE_SHARED_LINKER_FLAGS\n        \"${CMAKE_SHARED_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}\")\n      set(CMAKE_MODULE_LINKER_FLAGS\n        \"${CMAKE_MODULE_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}\")\n    endif()\n    \n    # Work around a broken bfd ld behavior. When linking a binary with a\n    # foo.so library, it will try to find any library that foo.so uses and\n    # check its symbols. This is wasteful (the check was done when foo.so\n    # was created) and can fail since it is not the dynamic linker and\n    # doesn't know how to handle search paths correctly.\n    if (UNIX AND NOT APPLE AND NOT ${CMAKE_SYSTEM_NAME} MATCHES \"SunOS|AIX\")\n      set(CMAKE_EXE_LINKER_FLAGS\n          \"${CMAKE_EXE_LINKER_FLAGS} -Wl,-allow-shlib-undefined\")\n    endif()\n    \n    if(${CMAKE_SYSTEM_NAME} MATCHES \"(FreeBSD|DragonFly)\")\n      # On FreeBSD, \/usr\/local\/* is not used by default. In order to build LLVM\n      # with libxml2, iconv.h, etc., we must add \/usr\/local paths.\n      include_directories(\"\/usr\/local\/include\")\n      link_directories(\"\/usr\/local\/lib\")\n    endif(${CMAKE_SYSTEM_NAME} MATCHES \"(FreeBSD|DragonFly)\")\n    \n    if( ${CMAKE_SYSTEM_NAME} MATCHES SunOS )\n       SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -include llvm\/Support\/Solaris.h\")\n    endif( ${CMAKE_SYSTEM_NAME} MATCHES SunOS )\n    \n    # Make sure we don't get -rdynamic in every binary. For those that need it,\n    # use export_executable_symbols(target).\n    set(CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS \"\")\n    \n    set(LLVM_PROFDATA_FILE \"\" CACHE FILEPATH\n      \"Profiling data file to use when compiling in order to improve runtime performance.\")\n    \n    if(LLVM_PROFDATA_FILE AND EXISTS ${LLVM_PROFDATA_FILE})\n      if (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"Clang\" )\n        add_definitions(\"-fprofile-instr-use=${LLVM_PROFDATA_FILE}\")\n      else()\n        message(FATAL_ERROR \"LLVM_PROFDATA_FILE can only be specified when compiling with clang\")\n      endif()\n    endif()\n    \n    #include(AddLLVM)\n    #include(TableGen)\n    \n      # LLVM_REQUIRES_EH is an internal flag that individual targets can use to\n      # force EH\n      if(LLVM_REQUIRES_EH OR LLVM_ENABLE_EH)\n        if(NOT (LLVM_REQUIRES_RTTI OR LLVM_ENABLE_RTTI))\n          message(AUTHOR_WARNING \"Exception handling requires RTTI. Enabling RTTI for ${name}\")\n          set(LLVM_REQUIRES_RTTI ON)\n        endif()\n        if(MSVC)\n          set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} \/EHsc\")\n        endif()\n      else()\n        if(LLVM_COMPILER_IS_GCC_COMPATIBLE)\n          set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fno-exceptions\")\n        elseif(MSVC)\n          add_definitions(-D_HAS_EXCEPTIONS=0)\n          set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} \/EHs-c-\")\n        endif()\n      endif()\n    \n      # LLVM_REQUIRES_RTTI is an internal flag that individual\n      # targets can use to force RTTI\n      set(LLVM_CONFIG_HAS_RTTI YES CACHE INTERNAL \"\")\n      if(NOT (LLVM_REQUIRES_RTTI OR LLVM_ENABLE_RTTI))\n        set(LLVM_CONFIG_HAS_RTTI NO CACHE INTERNAL \"\")\n          add_definitions(-DGTEST_HAS_RTTI=0)\n        if (LLVM_COMPILER_IS_GCC_COMPATIBLE)\n          set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fno-rtti\")\n        elseif (MSVC)\n          set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} \/GR-\")\n        endif ()\n      elseif(MSVC)\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} \/GR\")\n      endif()\n    \n    \n    if( MINGW )\n      # People report that -O3 is unreliable on MinGW. The traditional\n      # build also uses -O2 for that reason:\n      llvm_replace_compiler_option(CMAKE_CXX_FLAGS_RELEASE \"-O3\" \"-O2\")\n    endif()\n    \n    \n    ################################################################################\n    #\n    # tablegen\n    #\n    ################################################################################\n    \n    set(LLVM_TABLEGEN_FLAGS -I ${SDIR}\/include)\n    \n    function(tablegen project ofn)\n      # Validate calling context.\n      if(NOT ${project}_TABLEGEN_EXE)\n        message(FATAL_ERROR \"${project}_TABLEGEN_EXE not set\")\n      endif()\n    \n      file(GLOB local_tds \"*.td\")\n      file(GLOB_RECURSE global_tds \"${SDIR}\/include\/llvm\/*.td\")\n    \n      if (IS_ABSOLUTE ${LLVM_TARGET_DEFINITIONS})\n        set(LLVM_TARGET_DEFINITIONS_ABSOLUTE ${LLVM_TARGET_DEFINITIONS})\n      else()\n        set(LLVM_TARGET_DEFINITIONS_ABSOLUTE\n          ${CMAKE_CURRENT_SOURCE_DIR}\/${LLVM_TARGET_DEFINITIONS})\n      endif()\n      if (LLVM_ENABLE_DAGISEL_COV)\n        list(FIND ARGN \"-gen-dag-isel\" idx)\n        if( NOT idx EQUAL -1 )\n          list(APPEND LLVM_TABLEGEN_FLAGS \"-instrument-coverage\")\n        endif()\n      endif()\n    \n      add_custom_command(OUTPUT ${ofn}.tmp\n        # Generate tablegen output in a temporary file.\n        COMMAND ${${project}_TABLEGEN_EXE} ${ARGN} -I ${CMAKE_CURRENT_SOURCE_DIR}\n        ${LLVM_TABLEGEN_FLAGS}\n        ${LLVM_TARGET_DEFINITIONS_ABSOLUTE}\n        -o ${ofn}.tmp\n        # The file in LLVM_TARGET_DEFINITIONS may be not in the current\n        # directory and local_tds may not contain it, so we must\n        # explicitly list it here:\n        DEPENDS ${${project}_TABLEGEN_TARGET} ${local_tds} ${global_tds}\n        ${LLVM_TARGET_DEFINITIONS_ABSOLUTE}\n        COMMENT \"Building ${ofn}...\"\n        )\n      add_custom_command(OUTPUT ${ofn}\n        # Only update the real output file if there are any differences.\n        # This prevents recompilation of all the files depending on it if there\n        # aren't any.\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n            ${ofn}.tmp\n            ${ofn}\n        DEPENDS ${ofn}.tmp\n        COMMENT \"Updating ${ofn}...\"\n        )\n    \n      set(src ${src} ${ofn} PARENT_SCOPE)\n      set(TABLEGEN_OUTPUT ${TABLEGEN_OUTPUT} ${ofn} PARENT_SCOPE)\n      set_source_files_properties(${ofn} PROPERTIES GENERATED 1)\n    endfunction()\n\npost_target: |\n    set(x ${CMAKE_CXX_FLAGS})\n    string(REPLACE \" \" \";\" x ${x})\n    foreach(f ${x})\n        target_compile_options(${this} PRIVATE ${f})\n    endforeach()\n\n",
    "source": {
        "git": {
            "url": "https:\/\/github.com\/llvm-mirror\/llvm",
            "branch": "master"
        }
    },
    "hash": "beb1bc9c3d770d8af832b5a9a070dc68f3cc8413238fbc53055028a1542563db",
    "created": "2017-06-04 22:00:24.061527"
}
